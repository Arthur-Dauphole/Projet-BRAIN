import json
import matplotlib.pyplot as plt
import numpy as np
from collections import defaultdict, Counter
from typing import List, Dict, Tuple, Set, Optional, Any
import copy
from dataclasses import dataclass, field
import statistics

# ============================================
# PARTIE 1: STRUCTURES DE DONNÉES POUR RÈGLES
# ============================================

@dataclass
class Rule:
    """Représente une règle de transformation."""
    rule_type: str  # 'color_change', 'translation', 'connection'
    params: Dict[str, Any]
    examples: List[int] = field(default_factory=list)
    confidence: float = 1.0
    
    def __hash__(self):
        return hash((self.rule_type, tuple(sorted(self.params.items()))))
    
    def __eq__(self, other):
        if not isinstance(other, Rule):
            return False
        return (self.rule_type == other.rule_type and 
                self.params == other.params)

@dataclass
class ConsolidatedRules:
    """Règles consolidées de tous les exemples."""
    color_changes: Dict[int, int]
    general_color_changes: List[Rule]
    translations: Dict[int, Tuple[int, int]]
    general_translations: List[Rule]
    connections: Dict[int, List[str]]  # MODIF: Liste de types de connexion
    general_connections: List[Rule]
    
    def get_all_rules(self) -> Dict:
        return {
            "color_changes": self.color_changes,
            "translations": self.translations,
            "connections": self.connections,
            "general_color_changes": [r.params for r in self.general_color_changes],
            "general_translations": [r.params for r in self.general_translations],
            "general_connections": [r.params for r in self.general_connections]
        }

# ============================================
# PARTIE 2: GESTION DES COULEURS ET VISUALISATION AMÉLIORÉE
# ============================================

class ColorMapper:
    """Mappe les codes de couleur (0-9) vers des couleurs hexadécimales."""
    COLOR_MAP = {
        0: "#000000",  # Noir (fond)
        1: "#FF6B6B",  # Rouge clair
        2: "#4ECDC4",  # Turquoise
        3: "#FFD166",  # Jaune
        4: "#06D6A0",  # Vert
        5: "#118AB2",  # Bleu
        6: "#9D4EDD",  # Violet
        7: "#FF9E6D",  # Orange
        8: "#A8D5BA",  # Vert menthe
        9: "#CDB4DB",  # Lavande
    }
    
    @staticmethod
    def hex(color_code: int) -> str:
        return ColorMapper.COLOR_MAP.get(color_code, "#FFFFFF")
    
    @staticmethod
    def name(color_code: int) -> str:
        names = {
            0: "Noir", 1: "Rouge", 2: "Turquoise", 3: "Jaune", 4: "Vert",
            5: "Bleu", 6: "Violet", 7: "Orange", 8: "Menthe", 9: "Lavande"
        }
        return names.get(color_code, f"Couleur {color_code}")

def grid_to_rgb(grid: List[List[int]]) -> np.ndarray:
    """Convertit une grille en tableau RGB."""
    h, w = len(grid), len(grid[0])
    rgb_array = np.zeros((h, w, 3))
    
    for y in range(h):
        for x in range(w):
            hex_color = ColorMapper.hex(grid[y][x])
            hex_color = hex_color.lstrip('#')
            rgb = tuple(int(hex_color[i:i+2], 16) / 255.0 
                       for i in (0, 2, 4))
            rgb_array[y, x] = rgb
    
    return rgb_array

def visualize_grid_with_gridlines(grid: List[List[int]], ax, title: str = "", show_gridlines: bool = True):
    """Visualise une grille avec des lignes de grille."""
    h, w = len(grid), len(grid[0])
    
    # Afficher l'image
    im = ax.imshow(grid_to_rgb(grid))
    ax.set_title(title, fontsize=14, fontweight='bold', pad=20)
    
    if show_gridlines:
        # Ajouter des lignes de grille fines
        ax.set_xticks(np.arange(-0.5, w, 1), minor=True)
        ax.set_yticks(np.arange(-0.5, h, 1), minor=True)
        ax.grid(which='minor', color='white', linewidth=1.5, alpha=0.7)
    
    # Désactiver les ticks
    ax.tick_params(which='both', 
                  bottom=False, left=False, 
                  labelbottom=False, labelleft=False)
    
    # Ajouter des bordures autour de chaque cellule
    if show_gridlines:
        for x in range(w):
            for y in range(h):
                # CORRECTION: Utiliser un tuple RGBA au lieu d'une chaîne
                rect = plt.Rectangle((x-0.5, y-0.5), 1, 1,
                                   linewidth=1, edgecolor=(1, 1, 1, 0.3),
                                   facecolor='none')
                ax.add_patch(rect)
    
    return im

def visualize_grids(input_grid: List[List[int]], 
                   output_grid: List[List[int]], 
                   title_left: str = "INPUT",
                   title_right: str = "OUTPUT",
                   rules_text: str = "",
                   show_gridlines: bool = True):
    """Visualise deux grilles côte à côte avec des règles."""
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 7))
    
    # --- Grille d'entrée ---
    visualize_grid_with_gridlines(input_grid, ax1, title_left, show_gridlines)
    
    # --- Grille de sortie ---
    visualize_grid_with_gridlines(output_grid, ax2, title_right, show_gridlines)
    
    # Ajouter les règles en bas si fournies
    if rules_text:
        fig.text(0.5, 0.02, rules_text, 
                ha='center', va='bottom',
                fontsize=10, 
                bbox=dict(boxstyle='round', facecolor='lightblue', alpha=0.8))
        plt.subplots_adjust(bottom=0.25)
    
    # Légende des couleurs
    legend_elements = []
    colors_in_grid = set()
    
    for row in input_grid + output_grid:
        colors_in_grid.update(set(row))
    
    colors_in_grid = sorted(list(colors_in_grid))
    for color in colors_in_grid:
        if color != 0:
            legend_elements.append(
                plt.Rectangle((0, 0), 1, 1, 
                            facecolor=ColorMapper.hex(color),
                            label=f"{color}: {ColorMapper.name(color)}")
            )
    
    if legend_elements:
        fig.legend(handles=legend_elements, 
                  loc='upper center', 
                  ncol=min(6, len(legend_elements)),
                  bbox_to_anchor=(0.5, 0.95),
                  fontsize=9)
    
    plt.suptitle("Analyse des Grilles - Système de Règles", 
                fontsize=16, fontweight='bold', y=0.98)
    plt.tight_layout(rect=[0, 0.05 if rules_text else 0, 1, 0.95])
    plt.show()

def visualize_rules_summary(rules: Dict):
    """Crée une visualisation des règles extraites avec mise en forme."""
    fig, ax = plt.subplots(1, 1, figsize=(12, 8))
    
    rules_text = "=== RÈGLES EXTRACTES ===\n\n"
    
    # Changements de couleur
    rules_text += "CHANGEMENTS DE COULEUR:\n"
    if rules.get('color_changes'):
        for old_color, new_color in rules['color_changes'].items():
            rules_text += f"  {old_color} → {new_color}\n"
    else:
        rules_text += "  Aucun\n"
    
    if rules.get('general_color_changes'):
        rules_text += "\n  Règles générales:\n"
        for rule in rules['general_color_changes']:
            if rule.get("type") == "add_constant":
                rules_text += f"    Ajouter {rule['value']} à toutes les couleurs\n"
            elif rule.get("all_to"):
                rules_text += f"    Toutes → {rule['all_to']}\n"
    
    # Translations
    rules_text += "\n↔TRANSLATIONS:\n"
    if rules.get('translations'):
        for color, (dx, dy) in rules['translations'].items():
            rules_text += f"  Couleur {color}: ({dx}, {dy})\n"
    else:
        rules_text += "  Aucune\n"
    
    if rules.get('general_translations'):
        rules_text += "\n  Règles générales:\n"
        for rule in rules['general_translations']:
            if rule.get("dx") is not None and rule.get("dy") is not None:
                rules_text += f"    Toutes: ({rule['dx']}, {rule['dy']})\n"
            elif rule.get("direction"):
                rules_text += f"    Direction: {rule['direction']}\n"
    
    # Connexions
    rules_text += "\nCONNEXIONS:\n"
    if rules.get('connections'):
        for color, conn_types in rules['connections'].items():
            if isinstance(conn_types, list):
                type_names = []
                for conn_type in conn_types:
                    type_name = {'H': 'Horizontale', 'V': 'Verticale', 'D': 'Diagonale'}.get(conn_type, conn_type)
                    type_names.append(type_name)
                rules_text += f"  Couleur {color}: {', '.join(type_names)}\n"
            else:
                type_name = {'H': 'Horizontale', 'V': 'Verticale', 'D': 'Diagonale'}.get(conn_types, conn_types)
                rules_text += f"  Couleur {color}: {type_name}\n"
    else:
        rules_text += "  Aucune\n"
    
    if rules.get('general_connections'):
        rules_text += "\n  Règles générales:\n"
        for rule in rules['general_connections']:
            conn_type = rule.get("connection_type")
            type_name = {'H': 'Horizontale', 'V': 'Verticale', 'D': 'Diagonale'}.get(conn_type, conn_type)
            rules_text += f"    Toutes: {type_name}\n"
    
    # Afficher le texte avec style
    ax.text(0.05, 0.5, rules_text, 
            fontsize=11, 
            verticalalignment='center',
            linespacing=1.5,
            bbox=dict(boxstyle='round', facecolor='#FFF3CD', alpha=0.9,
                     edgecolor='#FFC107', linewidth=2))
    
    ax.set_xlim(0, 1)
    ax.set_ylim(0, 1)
    ax.axis('off')
    ax.set_title("Règles Extraites des Exemples", fontsize=16, fontweight='bold', pad=20)
    
    plt.tight_layout()
    plt.show()

# ============================================
# PARTIE 3: CONSOLIDATEUR DE RÈGLES - MODIFIÉ
# ============================================

class RuleConsolidator:
    """Consolide les règles de différents exemples."""
    
    def __init__(self, min_confidence: float = 0.6):
        self.min_confidence = min_confidence
        
        self.all_color_changes = defaultdict(list)
        self.all_translations = defaultdict(list)
        self.all_connections = defaultdict(list)
    
    def add_example_rules(self, example_idx: int, 
                         color_changes: Dict[int, int],
                         translations: Dict[int, Tuple[int, int]],
                         connections: Dict[int, str]):
        """Ajoute les règles d'un exemple."""
        
        for old_color, new_color in color_changes.items():
            self.all_color_changes[old_color].append((new_color, example_idx))
        
        for color, translation in translations.items():
            self.all_translations[color].append((translation, example_idx))
        
        for color, conn_type in connections.items():
            self.all_connections[color].append((conn_type, example_idx))
    
    def consolidate(self) -> ConsolidatedRules:
        """Consolide toutes les règles."""
        
        color_changes = self._consolidate_color_changes()
        general_color_rules = self._extract_general_color_rules()
        
        translations = self._consolidate_translations()
        general_translation_rules = self._extract_general_translation_rules()
        
        connections = self._consolidate_connections()
        general_connection_rules = self._extract_general_connection_rules()
        
        return ConsolidatedRules(
            color_changes=color_changes,
            general_color_changes=general_color_rules,
            translations=translations,
            general_translations=general_translation_rules,
            connections=connections,
            general_connections=general_connection_rules
        )
    
    def _consolidate_color_changes(self) -> Dict[int, int]:
        """Consolide les changements de couleur."""
        consolidated = {}
        
        for old_color, changes in self.all_color_changes.items():
            if not changes:
                continue
                
            change_counter = Counter()
            for new_color, _ in changes:
                change_counter[new_color] += 1
            
            most_common = change_counter.most_common(1)[0]
            new_color, count = most_common
            
            confidence = count / len(changes)
            if confidence >= self.min_confidence:
                consolidated[old_color] = new_color
        
        return consolidated
    
    def _extract_general_color_rules(self) -> List[Rule]:
        """Extrait des règles générales de changement de couleur."""
        general_rules = []
        
        if not self.all_color_changes:
            return general_rules
        
        # Chercher des motifs comme "toutes les couleurs deviennent X"
        all_new_colors = []
        for changes in self.all_color_changes.values():
            for new_color, example_idx in changes:
                all_new_colors.append((new_color, example_idx))
        
        if all_new_colors:
            new_color_counter = Counter(new_color for new_color, _ in all_new_colors)
            most_common_new = new_color_counter.most_common(1)[0]
            common_color, count = most_common_new
            
            examples_with_rule = set(idx for _, idx in all_new_colors if _ == common_color)
            total_examples = len(set(idx for changes in self.all_color_changes.values() for _, idx in changes))
            
            if total_examples > 0:
                confidence = len(examples_with_rule) / total_examples
                if confidence >= self.min_confidence and len(examples_with_rule) >= 2:
                    rule = Rule(
                        rule_type="general_color_change",
                        params={"all_to": common_color},
                        examples=list(examples_with_rule),
                        confidence=confidence
                    )
                    general_rules.append(rule)
        
        return general_rules
    
    def _consolidate_translations(self) -> Dict[int, Tuple[int, int]]:
        """Consolide les translations."""
        consolidated = {}
        
        for color, translations in self.all_translations.items():
            if not translations:
                continue
                
            translation_counter = Counter()
            for (dx, dy), _ in translations:
                translation_counter[(dx, dy)] += 1
            
            most_common = translation_counter.most_common(1)[0]
            (dx, dy), count = most_common
            
            confidence = count / len(translations)
            if confidence >= self.min_confidence:
                consolidated[color] = (dx, dy)
        
        return consolidated
    
    def _extract_general_translation_rules(self) -> List[Rule]:
        """Extrait des règles générales de translation."""
        general_rules = []
        
        if not self.all_translations:
            return general_rules
        
        # Regrouper par vecteur de translation
        vector_to_data = defaultdict(lambda: {"colors": set(), "examples": set()})
        
        for color, translations in self.all_translations.items():
            for (dx, dy), example_idx in translations:
                vector = (dx, dy)
                vector_to_data[vector]["colors"].add(color)
                vector_to_data[vector]["examples"].add(example_idx)
        
        # Chercher des vecteurs qui apparaissent pour plusieurs couleurs
        for vector, data in vector_to_data.items():
            colors = data["colors"]
            examples = data["examples"]
            
            if len(colors) >= 2:
                dx, dy = vector
                
                total_translations = sum(len(translations) for translations in self.all_translations.values())
                if total_translations > 0:
                    all_examples_with_translations = set()
                    for translations in self.all_translations.values():
                        for _, example_idx in translations:
                            all_examples_with_translations.add(example_idx)
                    
                    if all_examples_with_translations:
                        confidence = len(examples) / len(all_examples_with_translations)
                        
                        if confidence >= self.min_confidence:
                            rule = Rule(
                                rule_type="general_translation",
                                params={"dx": dx, "dy": dy, "applies_to": "all_colors"},
                                examples=list(examples),
                                confidence=confidence
                            )
                            general_rules.append(rule)
        
        return general_rules
    
    def _consolidate_connections(self) -> Dict[int, List[str]]:  # MODIF: Retourne une liste
        """Consolide les connexions - version améliorée pour multiples types."""
        consolidated = defaultdict(list)
        
        for color, connections in self.all_connections.items():
            if not connections:
                continue
                
            connection_counter = Counter()
            for conn_type, _ in connections:
                connection_counter[conn_type] += 1
            
            # Garder TOUS les types avec confiance suffisante
            for conn_type, count in connection_counter.items():
                confidence = count / len(connections)
                if confidence >= self.min_confidence:
                    if conn_type not in consolidated[color]:
                        consolidated[color].append(conn_type)
        
        return dict(consolidated)
    
    def _extract_general_connection_rules(self) -> List[Rule]:
        """Extrait des règles générales de connexion."""
        general_rules = []
        
        if not self.all_connections:
            return general_rules
        
        # Regrouper par type de connexion
        type_to_data = defaultdict(lambda: {"colors": set(), "examples": set()})
        
        for color, connections in self.all_connections.items():
            for conn_type, example_idx in connections:
                type_to_data[conn_type]["colors"].add(color)
                type_to_data[conn_type]["examples"].add(example_idx)
        
        # Chercher des types qui apparaissent pour plusieurs couleurs
        for conn_type, data in type_to_data.items():
            colors = data["colors"]
            examples = data["examples"]
            
            if len(colors) >= 2:
                all_examples_with_connections = set()
                for connections in self.all_connections.values():
                    for _, example_idx in connections:
                        all_examples_with_connections.add(example_idx)
                
                if all_examples_with_connections:
                    confidence = len(examples) / len(all_examples_with_connections)
                    
                    if confidence >= self.min_confidence:
                        rule = Rule(
                            rule_type="general_connection",
                            params={"connection_type": conn_type, "applies_to": "all_colors"},
                            examples=list(examples),
                            confidence=confidence
                        )
                        general_rules.append(rule)
        
        return general_rules

# ============================================
# PARTIE 4: EXTRACTION DE RÈGLES - MODIFIÉ
# ============================================

class AdvancedGridRuleExtractor:
    """Extrait et consolide les règles de tous les exemples."""
    
    def __init__(self, min_confidence: float = 0.6):
        self.consolidator = RuleConsolidator(min_confidence)
        self.example_rules = []
        
    def extract_and_consolidate(self, train_examples: List[Dict]) -> ConsolidatedRules:
        """Extrait les règles de chaque exemple et les consolide."""
        print("="*60)
        print("EXTRACTION ET CONSOLIDATION DES RÈGLES")
        print("="*60)
        
        for idx, example in enumerate(train_examples):
            print(f"\n--- Analyse de l'exemple {idx+1} ---")
            
            input_grid = example["input"]
            output_grid = example["output"]
            
            color_changes, translations, connections = self._extract_single_example(input_grid, output_grid)
            
            self.example_rules.append({
                "color_changes": color_changes,
                "translations": translations,
                "connections": connections
            })
            
            self.consolidator.add_example_rules(
                idx, color_changes, translations, connections
            )
        
        print("\n" + "="*60)
        print("CONSOLIDATION FINALE")
        print("="*60)
        return self.consolidator.consolidate()
    
    def _extract_single_example(self, input_grid: List[List[int]], 
                               output_grid: List[List[int]]) -> Tuple[Dict, Dict, Dict]:
        """Extrait les règles d'un seul exemple."""
        color_changes = {}
        translations = {}
        connections = {}
        
        h = len(input_grid)
        w = len(input_grid[0])
        
        input_points_by_color = defaultdict(set)
        output_points_by_color = defaultdict(set)
        
        # 1. Changements de couleur
        for i in range(h):
            for j in range(w):
                old_color = input_grid[i][j]
                new_color = output_grid[i][j]
                
                if old_color != 0 and old_color != new_color:
                    color_changes[old_color] = new_color
                
                if old_color != 0:
                    input_points_by_color[old_color].add((i, j))
                if new_color != 0:
                    output_points_by_color[new_color].add((i, j))
        
        # 2. Pour chaque couleur en sortie
        for color_out in output_points_by_color.keys():
            possible_input_colors = []
            
            for old_color, new_color in color_changes.items():
                if new_color == color_out:
                    possible_input_colors.append(old_color)
            
            if color_out not in color_changes.values():
                possible_input_colors.append(color_out)
            
            input_points_for_color = set()
            for c_in in possible_input_colors:
                if c_in in input_points_by_color:
                    input_points_for_color.update(input_points_by_color[c_in])
            
            output_points = output_points_by_color[color_out]
            
            if not input_points_for_color:
                continue
            
            # Détecter translation
            translation_found = self._try_detect_translation(
                input_points_for_color, output_points, color_out
            )
            if translation_found:
                dx, dy = translation_found
                translations[color_out] = (dx, dy)
            else:
                # Détecter connexions MULTIPLES - MODIFICATION IMPORTANTE
                conn_types = self._try_detect_all_connections(
                    input_points_for_color, output_points, color_out
                )
                if conn_types:
                    # Stocker le premier type détecté (compatibilité)
                    connections[color_out] = conn_types[0]
        
        return color_changes, translations, connections
    
    def _try_detect_translation(self, input_points: Set[Tuple[int, int]],
                               output_points: Set[Tuple[int, int]], 
                               color: int) -> Optional[Tuple[int, int]]:
        """Détecte une translation."""
        if len(input_points) != len(output_points) or not input_points:
            return None
        
        ref_in = next(iter(input_points))
        possible_displacements = set()
        
        for p_out in output_points:
            dx = p_out[0] - ref_in[0]
            dy = p_out[1] - ref_in[1]
            possible_displacements.add((dx, dy))
        
        for dx, dy in possible_displacements:
            match_all = True
            for p_in in input_points:
                moved = (p_in[0] + dx, p_in[1] + dy)
                if moved not in output_points:
                    match_all = False
                    break
            
            if match_all:
                for p_out in output_points:
                    original = (p_out[0] - dx, p_out[1] - dy)
                    if original not in input_points:
                        match_all = False
                        break
            
            if match_all:
                return (dx, dy)
        
        return None
    
    def _try_detect_all_connections(self, input_points: Set[Tuple[int, int]],
                                   output_points: Set[Tuple[int, int]],
                                   color: int) -> List[str]:
        """Détecte TOUTES les connexions possibles pour un ensemble de points."""
        base_points = input_points.intersection(output_points)
        added_points = output_points - input_points
        
        if not added_points or len(base_points) < 2:
            return []
        
        connection_types = []
        base_list = list(base_points)
        
        # Vérifier chaque paire de points
        for i in range(len(base_list)):
            for j in range(i+1, len(base_list)):
                p1 = base_list[i]
                p2 = base_list[j]
                
                # Horizontal
                if p1[0] == p2[0]:
                    min_y = min(p1[1], p2[1])
                    max_y = max(p1[1], p2[1])
                    line_points = {(p1[0], y) for y in range(min_y, max_y+1)}
                    
                    if line_points.issubset(output_points) and 'H' not in connection_types:
                        connection_types.append('H')
                
                # Vertical
                if p1[1] == p2[1]:
                    min_x = min(p1[0], p2[0])
                    max_x = max(p1[0], p2[0])
                    line_points = {(x, p1[1]) for x in range(min_x, max_x+1)}
                    
                    if line_points.issubset(output_points) and 'V' not in connection_types:
                        connection_types.append('V')
                
                # Diagonale
                if abs(p1[0] - p2[0]) == abs(p1[1] - p2[1]):
                    dx = 1 if p2[0] > p1[0] else -1
                    dy = 1 if p2[1] > p1[1] else -1
                    steps = abs(p2[0] - p1[0])
                    line_points = {(p1[0] + k*dx, p1[1] + k*dy) 
                                   for k in range(steps+1)}
                    
                    if line_points.issubset(output_points) and 'D' not in connection_types:
                        connection_types.append('D')
        
        return connection_types

# ============================================
# PARTIE 5: APPLICATION DES RÈGLES - VERSION AMÉLIORÉE
# ============================================

class AdvancedGridTransformer:
    """Applique les règles consolidées."""
    
    def __init__(self, consolidated_rules: ConsolidatedRules):
        self.rules = consolidated_rules
        
    def apply_rules(self, input_grid: List[List[int]]) -> List[List[int]]:
        """Applique les règles."""
        grid = copy.deepcopy(input_grid)
        h = len(grid)
        w = len(grid[0])
        
        # 1. Changements de couleur
        grid = self._apply_color_changes(grid)
        
        # 2. Connexions - VERSION AMÉLIORÉE pour multiples connexions
        grid = self._apply_connections_enhanced(grid)
        
        # 3. Translations
        grid = self._apply_translations(grid)
        
        return grid
    
    def _apply_color_changes(self, grid: List[List[int]]) -> List[List[int]]:
        h = len(grid)
        w = len(grid[0])
        
        # Règles spécifiques
        for i in range(h):
            for j in range(w):
                color = grid[i][j]
                if color in self.rules.color_changes:
                    grid[i][j] = self.rules.color_changes[color]
        
        # Règles générales
        for rule in self.rules.general_color_changes:
            if rule.params.get("all_to") is not None:
                target_color = rule.params["all_to"]
                for i in range(h):
                    for j in range(w):
                        if grid[i][j] != 0:
                            grid[i][j] = target_color
        
        return grid
    
    def _apply_connections_enhanced(self, grid: List[List[int]]) -> List[List[int]]:
        """Nouvelle version: applique TOUS les types de connexion sans priorité."""
        h = len(grid)
        w = len(grid[0])
        
        # Créer une copie pour ne pas modifier pendant le tracé
        result_grid = copy.deepcopy(grid)
        
        # Pour chaque couleur avec des règles de connexion
        for color, conn_types in self.rules.connections.items():
            if not isinstance(conn_types, list):
                conn_types = [conn_types]
            
            # Trouver tous les points de cette couleur
            points = [(i, j) for i in range(h) for j in range(w) 
                     if grid[i][j] == color]
            
            if len(points) < 2:
                continue
            
            # Appliquer CHAQUE type de connexion
            for conn_type in conn_types:
                # Pour chaque paire de points
                for k in range(len(points)):
                    for l in range(k+1, len(points)):
                        p1 = points[k]
                        p2 = points[l]
                        
                        if conn_type == 'H' and p1[0] == p2[0]:  # Horizontal
                            self._draw_horizontal_line(result_grid, p1, p2, color)
                        
                        elif conn_type == 'V' and p1[1] == p2[1]:  # Vertical
                            self._draw_vertical_line(result_grid, p1, p2, color)
                        
                        elif conn_type == 'D':  # Diagonale
                            dx = p2[0] - p1[0]
                            dy = p2[1] - p1[1]
                            if abs(dx) == abs(dy):  # Vraie diagonale
                                self._draw_diagonal_line(result_grid, p1, p2, color)
        
        # Règles générales de connexion
        for rule in self.rules.general_connections:
            conn_type = rule.params["connection_type"]
            
            # Appliquer à toutes les couleurs présentes
            colors_in_grid = set()
            for i in range(h):
                for j in range(w):
                    if grid[i][j] != 0:
                        colors_in_grid.add(grid[i][j])
            
            for color in colors_in_grid:
                # Ne pas réappliquer si déjà dans les règles spécifiques
                if color not in self.rules.connections or conn_type not in self.rules.connections.get(color, []):
                    points = [(i, j) for i in range(h) for j in range(w) 
                             if grid[i][j] == color]
                    
                    if len(points) < 2:
                        continue
                    
                    for k in range(len(points)):
                        for l in range(k+1, len(points)):
                            p1 = points[k]
                            p2 = points[l]
                            
                            if conn_type == 'H' and p1[0] == p2[0]:
                                self._draw_horizontal_line(result_grid, p1, p2, color)
                            elif conn_type == 'V' and p1[1] == p2[1]:
                                self._draw_vertical_line(result_grid, p1, p2, color)
                            elif conn_type == 'D':
                                dx = p2[0] - p1[0]
                                dy = p2[1] - p1[1]
                                if abs(dx) == abs(dy):
                                    self._draw_diagonal_line(result_grid, p1, p2, color)
        
        return result_grid
    
    def _draw_horizontal_line(self, grid: List[List[int]], 
                            p1: Tuple[int, int], p2: Tuple[int, int], 
                            color: int) -> None:
        row = p1[0]
        start_col = min(p1[1], p2[1])
        end_col = max(p1[1], p2[1])
        
        for col in range(start_col, end_col + 1):
            if grid[row][col] == 0:
                grid[row][col] = color
    
    def _draw_vertical_line(self, grid: List[List[int]], 
                          p1: Tuple[int, int], p2: Tuple[int, int], 
                          color: int) -> None:
        col = p1[1]
        start_row = min(p1[0], p2[0])
        end_row = max(p1[0], p2[0])
        
        for row in range(start_row, end_row + 1):
            if grid[row][col] == 0:
                grid[row][col] = color
    
    def _draw_diagonal_line(self, grid: List[List[int]], 
                          p1: Tuple[int, int], p2: Tuple[int, int], 
                          color: int) -> None:
        dx = 1 if p2[0] > p1[0] else -1
        dy = 1 if p2[1] > p1[1] else -1
        steps = abs(p2[0] - p1[0])
        
        for step in range(steps + 1):
            row = p1[0] + step * dx
            col = p1[1] + step * dy
            if grid[row][col] == 0:
                grid[row][col] = color
    
    def _apply_translations(self, grid: List[List[int]]) -> List[List[int]]:
        h = len(grid)
        w = len(grid[0])
        
        new_grid = [[0 for _ in range(w)] for _ in range(h)]
        
        # Copier ce qui ne sera pas translaté
        for i in range(h):
            for j in range(w):
                color = grid[i][j]
                if color != 0:
                    if color in self.rules.translations:
                        continue
                    
                    has_general = any(r.params.get("applies_to") == "all_colors" 
                                    for r in self.rules.general_translations)
                    if not has_general:
                        new_grid[i][j] = color
        
        # Appliquer translations spécifiques
        for color, (dx, dy) in self.rules.translations.items():
            for i in range(h):
                for j in range(w):
                    if grid[i][j] == color:
                        new_i = i + dy
                        new_j = j + dx
                        if 0 <= new_i < h and 0 <= new_j < w:
                            new_grid[new_i][new_j] = color
        
        # Appliquer translations générales
        for rule in self.rules.general_translations:
            if rule.params.get("applies_to") == "all_colors":
                dx = rule.params.get("dx", 0)
                dy = rule.params.get("dy", 0)
                for i in range(h):
                    for j in range(w):
                        color = grid[i][j]
                        if color != 0 and color not in self.rules.translations:
                            new_i = i + dy
                            new_j = j + dx
                            if 0 <= new_i < h and 0 <= new_j < w:
                                new_grid[new_i][new_j] = color
        
        return new_grid

# ============================================
# PARTIE 6: FONCTIONS PRINCIPALES AMÉLIORÉES
# ============================================

def load_data_from_json(filepath: str) -> Dict:
    with open(filepath, 'r', encoding='utf-8') as f:
        return json.load(f)

def save_results_to_json(results: Dict, filepath: str) -> None:
    with open(filepath, 'w', encoding='utf-8') as f:
        json.dump(results, f, indent=2)

def visualize_test_results(test_cases: List[Dict], results: List[List[List[int]]], 
                          consolidated_rules: ConsolidatedRules):
    """Visualise les résultats des tests avec les règles."""
    
    all_rules = consolidated_rules.get_all_rules()
    
    for test_idx, (test_case, result_grid) in enumerate(zip(test_cases, results)):
        input_grid = test_case["input"]
        
        # Créer une figure avec 3 sous-graphiques
        fig, axes = plt.subplots(1, 3, figsize=(18, 6))
        
        # Input
        visualize_grid_with_gridlines(input_grid, axes[0], f"TEST {test_idx+1} - INPUT", True)
        
        # Output prédit
        visualize_grid_with_gridlines(result_grid, axes[1], f"TEST {test_idx+1} - OUTPUT PRÉDIT", True)
        
        # Règles appliquées
        ax3 = axes[2]
        ax3.axis('off')
        
        rules_text = f"RÈGLES APPLIQUÉES AU TEST {test_idx+1}\n\n"
        rules_text += "="*30 + "\n\n"
        
        # Couleurs présentes dans l'input
        colors_present = set()
        for row in input_grid:
            colors_present.update(set(row))
        colors_present.discard(0)
        
        if colors_present:
            rules_text += "Couleurs détectées: " + ", ".join(str(c) for c in sorted(colors_present)) + "\n\n"
        
        # Règles qui s'appliquent
        applied_rules = []
        
        # Changements de couleur
        for color in colors_present:
            if color in all_rules['color_changes']:
                applied_rules.append(f"• {color} → {all_rules['color_changes'][color]}")
        
        # Translations
        for color in colors_present:
            if color in all_rules['translations']:
                dx, dy = all_rules['translations'][color]
                applied_rules.append(f"• Translation {color}: ({dx}, {dy})")
        
        # Connexions
        for color in colors_present:
            if color in all_rules['connections']:
                conn_types = all_rules['connections'][color]
                if isinstance(conn_types, list):
                    type_names = []
                    for ct in conn_types:
                        name = {'H': 'Horizontale', 'V': 'Verticale', 'D': 'Diagonale'}.get(ct, ct)
                        type_names.append(name)
                    applied_rules.append(f"• Connexions {color}: {', '.join(type_names)}")
                else:
                    name = {'H': 'Horizontale', 'V': 'Verticale', 'D': 'Diagonale'}.get(conn_types, conn_types)
                    applied_rules.append(f"• Connexion {color}: {name}")
        
        # Règles générales
        if all_rules['general_color_changes']:
            applied_rules.append("• Règle générale de changement de couleur")
        
        if all_rules['general_translations']:
            applied_rules.append("• Règle générale de translation")
        
        if all_rules['general_connections']:
            applied_rules.append("• Règle générale de connexion")
        
        if applied_rules:
            rules_text += "Règles appliquées:\n" + "\n".join(applied_rules)
        else:
            rules_text += "Aucune règle spécifique appliquée"
        
        ax3.text(0.1, 0.5, rules_text, fontsize=10, verticalalignment='center',
                bbox=dict(boxstyle='round', facecolor='#E8F4FD', alpha=0.9))
        
        plt.suptitle(f"RÉSULTAT DU TEST {test_idx+1}", fontsize=16, fontweight='bold')
        plt.tight_layout()
        plt.show()

def main(visualize: bool = True, json_file: str = "grid_data.json"):
    """Fonction principale améliorée."""
    
    print("Chargement des données...")
    try:
        data = load_data_from_json(json_file)
    except FileNotFoundError:
        print(f"Erreur: Fichier '{json_file}' non trouvé.")
        return
    
    # Extraire et consolider
    print("\nExtraction et consolidation des règles...")
    extractor = AdvancedGridRuleExtractor(min_confidence=0.5)
    consolidated_rules = extractor.extract_and_consolidate(data["train"])
    
    # Afficher règles
    print("\n" + "="*60)
    print("RÈGLES FINALES (CONSOLIDÉES)")
    print("="*60)
    
    all_rules = consolidated_rules.get_all_rules()
    
    # Afficher dans la console
    print(f"\nChangements de couleur spécifiques: {all_rules['color_changes']}")
    print(f"Translations spécifiques: {all_rules['translations']}")
    print(f"Connexions spécifiques: {all_rules['connections']}")
    
    if all_rules['general_color_changes']:
        print(f"Changements généraux: {all_rules['general_color_changes']}")
    if all_rules['general_translations']:
        print(f"Translations générales: {all_rules['general_translations']}")
    if all_rules['general_connections']:
        print(f"Connexions générales: {all_rules['general_connections']}")
    
    # Visualiser les règles
    if visualize:
        visualize_rules_summary(all_rules)
    
    # Appliquer aux tests
    print(f"\n" + "="*60)
    print("APPLICATION AUX TESTS")
    print("="*60)
    
    transformer = AdvancedGridTransformer(consolidated_rules)
    results = []
    
    test_key = "Test" if "Test" in data else "test"
    
    if test_key in data:
        for test_idx, test_case in enumerate(data[test_key]):
            print(f"\n=== TEST {test_idx + 1} ===")
            
            input_grid = test_case["input"]
            
            # Afficher input condensé
            print(f"Input (taille: {len(input_grid)}x{len(input_grid[0])}):")
            if len(input_grid) <= 8:
                for row in input_grid:
                    print("  " + str(row))
            else:
                for row in input_grid[:4]:
                    print("  " + str(row))
                print("  ...")
                for row in input_grid[-4:]:
                    print("  " + str(row))
            
            # Générer output
            output_grid = transformer.apply_rules(input_grid)
            
            print("\nOutput prédit:")
            if len(output_grid) <= 8:
                for row in output_grid:
                    print("  " + str(row))
            else:
                for row in output_grid[:4]:
                    print("  " + str(row))
                print("  ...")
                for row in output_grid[-4:]:
                    print("  " + str(row))
            
            results.append({
                "input": input_grid,
                "output": output_grid
            })
        
        # Visualiser les résultats des tests
        if visualize:
            visualize_test_results(data[test_key], [r["output"] for r in results], consolidated_rules)
    
    # Sauvegarder
    output_file = "grid_results_consolidated.json"
    save_results_to_json({"test_results": results}, output_file)
    
    print(f"\n✓ Terminé! {len(results)} test(s) sauvegardés dans '{output_file}'")
    
    return results, consolidated_rules

# ============================================
# EXÉCUTION
# ============================================

if __name__ == "__main__":
    import sys
    
    print("="*70)
    print("SYSTÈME AVEC CONSOLIDATION INTER-EXEMPLES - VERSION AMÉLIORÉE")
    print("="*70)
    print("Améliorations:")
    print("1. Lignes de grille visibles")
    print("2. Visualisation des règles en image")
    print("3. Connexions multiples sans priorité")
    print("4. Interface améliorée")
    print("="*70)
    
    json_file = input("Nom du fichier JSON (défaut: grid_data.json): ").strip()
    if not json_file:
        json_file = "grid_data.json"
    
    visualize_input = input("Visualisation? (oui/non): ").strip().lower()
    visualize = visualize_input in ["oui", "o", "yes", "y"]
    
    try:
        results, rules = main(visualize=visualize, json_file=json_file)
        print(f"\nRésumé: {len(results)} test(s) traités avec succès")
    except Exception as e:
        print(f"\n✗ Erreur: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
