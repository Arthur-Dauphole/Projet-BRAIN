"""
SYSTÈME COMPLET DE RÉSOLUTION DE GRID ARC
Intègre: 
1. Structures géométriques (Points, BoundingBox, Formes)
2. Détecteurs de formes (Rectangles, Lignes, Symétries)
3. Extraction et application de règles
4. Visualisation
"""

import json
import matplotlib.pyplot as plt
import numpy as np
from collections import defaultdict
from typing import List, Dict, Tuple, Set, Optional
import copy
from dataclasses import dataclass, field
from enum import Enum

# ============================================
# PARTIE 1: STRUCTURES GÉOMÉTRIQUES (Code 1)
# ============================================

class Direction(Enum):
    """Directions cardinales et intercardinales."""
    NORTH = (0, -1)
    SOUTH = (0, 1)
    EAST = (1, 0)
    WEST = (-1, 0)
    NORTHEAST = (1, -1)
    NORTHWEST = (-1, -1)
    SOUTHEAST = (1, 1)
    SOUTHWEST = (-1, 1)

    @classmethod
    def cardinal(cls) -> list["Direction"]:
        return [cls.NORTH, cls.SOUTH, cls.EAST, cls.WEST]

    @classmethod
    def all_directions(cls) -> list["Direction"]:
        return list(cls)


@dataclass(frozen=True)
class Point:
    """Point 2D en coordonnées de grille."""
    x: int
    y: int

    def __add__(self, other: "Point") -> "Point":
        return Point(self.x + other.x, self.y + other.y)

    def __hash__(self) -> int:
        return hash((self.x, self.y))

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Point):
            return False
        return self.x == other.x and self.y == other.y

    def to_tuple(self) -> tuple[int, int]:
        return self.x, self.y

    def manhattan_distance(self, other: "Point") -> int:
        return abs(self.x - other.x) + abs(self.y - other.y)

    def euclidean_distance(self, other: "Point") -> float:
        return float(np.sqrt((self.x - other.x) ** 2 + (self.y - other.y) ** 2))


@dataclass
class BoundingBox:
    """Boîte englobante axis-alignée."""
    min_x: int
    min_y: int
    max_x: int
    max_y: int

    @property
    def width(self) -> int:
        return self.max_x - self.min_x + 1

    @property
    def height(self) -> int:
        return self.max_y - self.min_y + 1

    @property
    def area(self) -> int:
        return self.width * self.height

    @property
    def center(self) -> Point:
        return Point((self.min_x + self.max_x) // 2, (self.min_y + self.max_y) // 2)

    def contains(self, point: Point) -> bool:
        return self.min_x <= point.x <= self.max_x and self.min_y <= point.y <= self.max_y

    def corners(self) -> list[Point]:
        return [
            Point(self.min_x, self.min_y),
            Point(self.max_x, self.min_y),
            Point(self.max_x, self.max_y),
            Point(self.min_x, self.max_y),
        ]


@dataclass
class GeometricShape:
    """Forme géométrique détectée et ses propriétés."""
    shape_type: str  # 'rectangle', 'line', 'blob', etc.
    pixels: Set[Point]
    color: int
    bounding_box: BoundingBox
    properties: Dict = field(default_factory=dict)

    def __post_init__(self) -> None:
        if "area" not in self.properties:
            self.properties["area"] = len(self.pixels)
        if "density" not in self.properties:
            self.properties["density"] = len(self.pixels) / self.bounding_box.area

    def is_filled(self, threshold: float = 0.9) -> bool:
        return self.properties.get("density", 0.0) >= threshold

    def is_hollow(self, threshold: float = 0.5) -> bool:
        return self.properties.get("density", 1.0) <= threshold


# ============================================
# PARTIE 2: UTILITAIRES DE GRILLE
# ============================================

class GridUtils:
    """Utilitaires pour manipuler les grilles."""
    
    @staticmethod
    def list_to_numpy(grid: List[List[int]]) -> np.ndarray:
        """Convertit une liste de listes en numpy array."""
        return np.array(grid, dtype=int)
    
    @staticmethod
    def numpy_to_list(grid: np.ndarray) -> List[List[int]]:
        """Convertit un numpy array en liste de listes."""
        return grid.tolist()
    
    @staticmethod
    def extract_connected_components(grid: np.ndarray, background_color: int = 0) -> List[Set[Point]]:
        """Extrait les composantes connexes de la grille."""
        h, w = grid.shape
        visited = np.zeros((h, w), dtype=bool)
        components = []
        
        def bfs(start_x: int, start_y: int, color: int) -> Set[Point]:
            """BFS pour une composante connexe."""
            component = set()
            queue = [(start_x, start_y)]
            visited[start_y, start_x] = True
            
            while queue:
                x, y = queue.pop(0)
                component.add(Point(x, y))
                
                # Voisins (4-connexité)
                for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nx, ny = x + dx, y + dy
                    if (0 <= nx < w and 0 <= ny < h and 
                        not visited[ny, nx] and 
                        grid[ny, nx] == color):
                        visited[ny, nx] = True
                        queue.append((nx, ny))
            
            return component
        
        for y in range(h):
            for x in range(w):
                if not visited[y, x] and grid[y, x] != background_color:
                    component = bfs(x, y, grid[y, x])
                    if component:
                        components.append(component)
        
        return components
    
    @staticmethod
    def compute_bounding_box(points: Set[Point]) -> BoundingBox:
        """Calcule la bounding box d'un ensemble de points."""
        if not points:
            return BoundingBox(0, 0, 0, 0)
        
        xs = [p.x for p in points]
        ys = [p.y for p in points]
        
        return BoundingBox(
            min_x=min(xs),
            min_y=min(ys),
            max_x=max(xs),
            max_y=max(ys)
        )
    
    @staticmethod
    def get_border_pixels(pixels: Set[Point], grid_shape: Tuple[int, int]) -> Set[Point]:
        """Extrait les pixels de bordure d'une composante."""
        border = set()
        h, w = grid_shape
        
        for pixel in pixels:
            # Vérifier si le pixel a un voisin manquant (donc est sur le bord)
            neighbors = [
                Point(pixel.x + 1, pixel.y),
                Point(pixel.x - 1, pixel.y),
                Point(pixel.x, pixel.y + 1),
                Point(pixel.x, pixel.y - 1)
            ]
            
            # Si le pixel est sur le bord de la grille OU n'a pas tous ses voisins dans pixels
            if (pixel.x == 0 or pixel.x == w - 1 or 
                pixel.y == 0 or pixel.y == h - 1 or
                any(neighbor not in pixels for neighbor in neighbors)):
                border.add(pixel)
        
        return border


# ============================================
# PARTIE 3: DÉTECTEURS DE FORMES (Code 2)
# ============================================

class RectangleDetector:
    """Détecteur de rectangles."""
    
    @staticmethod
    def is_rectangle(pixels: Set[Point], bbox: BoundingBox, tolerance: float = 0.05) -> bool:
        expected_area = bbox.area
        actual_area = len(pixels)

        if expected_area == 0:
            return False

        if abs(actual_area - expected_area) / expected_area <= tolerance:
            return True

        border_area = 2 * (bbox.width + bbox.height) - 4
        if border_area > 0 and abs(actual_area - border_area) / border_area <= tolerance:
            return True

        return False

    @staticmethod
    def detect_rectangles(grid: List[List[int]], background_color: int = 0) -> List[GeometricShape]:
        np_grid = GridUtils.list_to_numpy(grid)
        components = GridUtils.extract_connected_components(np_grid, background_color)
        rectangles = []

        for component in components:
            if len(component) < 4:
                continue

            bbox = GridUtils.compute_bounding_box(component)

            if RectangleDetector.is_rectangle(component, bbox):
                sample_point = next(iter(component))
                color = np_grid[sample_point.y, sample_point.x]

                properties = {
                    "width": bbox.width,
                    "height": bbox.height,
                    "aspect_ratio": bbox.width / bbox.height if bbox.height else 0,
                    "is_square": abs(bbox.width - bbox.height) <= 1,
                    "perimeter": 2 * (bbox.width + bbox.height),
                }

                border = GridUtils.get_border_pixels(component, np_grid.shape)
                properties["is_filled"] = len(component) > len(border)
                properties["border_pixels"] = border
                properties["interior_pixels"] = component - border

                rectangles.append(
                    GeometricShape(
                        shape_type="rectangle",
                        pixels=component,
                        color=color,
                        bounding_box=bbox,
                        properties=properties,
                    )
                )

        return rectangles


class LineDetector:
    """Détecteur de lignes."""
    
    @staticmethod
    def is_line(pixels: Set[Point], tolerance: float = 0.1) -> Tuple[bool, Optional[str]]:
        if len(pixels) < 2:
            return False, None

        points_list = list(pixels)
        xs = {p.x for p in points_list}
        ys = {p.y for p in points_list}

        if len(ys) == 1:
            return True, "horizontal"

        if len(xs) == 1:
            return True, "vertical"

        if len(xs) == len(pixels) and len(ys) == len(pixels):
            x_range = max(xs) - min(xs)
            y_range = max(ys) - min(ys)
            if x_range == y_range:
                return True, "diagonal"

        return False, None

    @staticmethod
    def detect_lines(grid: List[List[int]], background_color: int = 0, min_length: int = 2) -> List[GeometricShape]:
        np_grid = GridUtils.list_to_numpy(grid)
        components = GridUtils.extract_connected_components(np_grid, background_color)
        lines = []

        for component in components:
            if len(component) < min_length:
                continue

            is_line, direction = LineDetector.is_line(component)

            if is_line and direction:
                sample_point = next(iter(component))
                color = np_grid[sample_point.y, sample_point.x]
                bbox = GridUtils.compute_bounding_box(component)

                points_list = list(component)
                if direction == "horizontal":
                    endpoints = [
                        min(points_list, key=lambda p: p.x),
                        max(points_list, key=lambda p: p.x),
                    ]
                elif direction == "vertical":
                    endpoints = [
                        min(points_list, key=lambda p: p.y),
                        max(points_list, key=lambda p: p.y),
                    ]
                else:  # diagonal
                    endpoints = [
                        min(points_list, key=lambda p: (p.x + p.y)),
                        max(points_list, key=lambda p: (p.x + p.y)),
                    ]

                properties = {
                    "direction": direction,
                    "length": len(component),
                    "endpoints": endpoints,
                    "thickness": 1,
                }

                lines.append(
                    GeometricShape(
                        shape_type="line",
                        pixels=component,
                        color=color,
                        bounding_box=bbox,
                        properties=properties,
                    )
                )

        return lines


class SymmetryDetector:
    """Détecteur de symétries."""
    
    @staticmethod
    def has_vertical_symmetry(pixels: Set[Point], tolerance: int = 0) -> bool:
        if not pixels:
            return False

        bbox = GridUtils.compute_bounding_box(pixels)
        center_x = (bbox.min_x + bbox.max_x) / 2

        for pixel in pixels:
            mirror_x = int(2 * center_x - pixel.x)
            mirror = Point(mirror_x, pixel.y)

            if mirror not in pixels:
                found_close = any(Point(mirror_x + dx, pixel.y) in pixels 
                               for dx in range(-tolerance, tolerance + 1))
                if not found_close:
                    return False

        return True

    @staticmethod
    def has_horizontal_symmetry(pixels: Set[Point], tolerance: int = 0) -> bool:
        if not pixels:
            return False

        bbox = GridUtils.compute_bounding_box(pixels)
        center_y = (bbox.min_y + bbox.max_y) / 2

        for pixel in pixels:
            mirror_y = int(2 * center_y - pixel.y)
            mirror = Point(pixel.x, mirror_y)

            if mirror not in pixels:
                found_close = any(Point(pixel.x, mirror_y + dy) in pixels 
                               for dy in range(-tolerance, tolerance + 1))
                if not found_close:
                    return False

        return True

    @staticmethod
    def detect_symmetries(shape: GeometricShape) -> Dict[str, bool]:
        return {
            "vertical_symmetry": SymmetryDetector.has_vertical_symmetry(shape.pixels),
            "horizontal_symmetry": SymmetryDetector.has_horizontal_symmetry(shape.pixels),
        }


# ============================================
# PARTIE 4: GESTION DES COULEURS ET VISUALISATION
# ============================================

class ColorMapper:
    """Mappe les codes de couleur vers des couleurs hexadécimales."""
    COLOR_MAP = {
        0: "#000000",  # Noir
        1: "#0074D9",  # Bleu
        2: "#FF4136",  # Rouge
        3: "#2ECC40",  # Vert
        4: "#FFDC00",  # Jaune
        5: "#AAAAAA",  # Gris
        6: "#F012BE",  # Magenta
        7: "#FF851B",  # Orange
        8: "#7FDBFF",  # Cyan
        9: "#870C25",  # Marron
    }
    
    @staticmethod
    def hex(color_code: int) -> str:
        return ColorMapper.COLOR_MAP.get(color_code, "#FFFFFF")
    
    @staticmethod
    def name(color_code: int) -> str:
        names = {
            0: "Noir", 1: "Bleu", 2: "Rouge", 3: "Vert", 4: "Jaune",
            5: "Gris", 6: "Magenta", 7: "Orange", 8: "Cyan", 9: "Marron"
        }
        return names.get(color_code, f"Couleur {color_code}")


def grid_to_rgb(grid: List[List[int]]) -> np.ndarray:
    """Convertit une grille en tableau RGB."""
    h, w = len(grid), len(grid[0])
    rgb_array = np.zeros((h, w, 3))
    
    for y in range(h):
        for x in range(w):
            hex_color = ColorMapper.hex(grid[y][x])
            hex_color = hex_color.lstrip('#')
            rgb = tuple(int(hex_color[i:i+2], 16) / 255.0 
                       for i in (0, 2, 4))
            rgb_array[y, x] = rgb
    
    return rgb_array


def visualize_shapes(grid: List[List[int]], shapes: List[GeometricShape], title: str = "Détection de formes"):
    """Visualise une grille avec les formes détectées."""
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 6))
    
    # Grille originale
    ax1.imshow(grid_to_rgb(grid))
    ax1.set_title("Grille originale", fontsize=12, fontweight='bold')
    
    # Grille avec formes annotées
    rgb_grid = grid_to_rgb(grid)
    ax2.imshow(rgb_grid)
    ax2.set_title("Formes détectées", fontsize=12, fontweight='bold')
    
    # Annoter les formes
    for idx, shape in enumerate(shapes):
        bbox = shape.bounding_box
        rect = plt.Rectangle(
            (bbox.min_x - 0.5, bbox.min_y - 0.5),
            bbox.width,
            bbox.height,
            linewidth=2,
            edgecolor='white',
            facecolor='none'
        )
        ax2.add_patch(rect)
        
        # Afficher le type de forme
        ax2.text(
            bbox.min_x, 
            bbox.min_y - 2,
            f"{shape.shape_type} ({shape.color})",
            color='white',
            fontsize=8,
            fontweight='bold',
            bbox=dict(boxstyle='round', facecolor='red', alpha=0.5)
        )
    
    for ax in [ax1, ax2]:
        h, w = len(grid), len(grid[0])
        ax.set_xticks(np.arange(-0.5, w, 1), minor=True)
        ax.set_yticks(np.arange(-0.5, h, 1), minor=True)
        ax.grid(which='minor', color='white', linewidth=0.5, alpha=0.3)
        ax.tick_params(which='both', bottom=False, left=False, labelbottom=False, labelleft=False)
    
    plt.suptitle(title, fontsize=14, fontweight='bold')
    plt.tight_layout()
    plt.show()


def visualize_grids(input_grid: List[List[int]], 
                   output_grid: List[List[int]], 
                   title_left: str = "INPUT",
                   title_right: str = "OUTPUT",
                   rules_text: str = ""):
    """Visualise deux grilles côte à côte avec des règles."""
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 7))
    
    ax1.imshow(grid_to_rgb(input_grid))
    ax1.set_title(title_left, fontsize=14, fontweight='bold', pad=20)
    
    ax2.imshow(grid_to_rgb(output_grid))
    ax2.set_title(title_right, fontsize=14, fontweight='bold', pad=20)
    
    if rules_text:
        fig.text(0.5, 0.02, rules_text, 
                ha='center', va='bottom',
                fontsize=11, 
                bbox=dict(boxstyle='round', facecolor='lightblue', alpha=0.8))
        plt.subplots_adjust(bottom=0.25)
    
    for ax in [ax1, ax2]:
        h, w = len(input_grid), len(input_grid[0])
        ax.set_xticks(np.arange(-0.5, w, 1), minor=True)
        ax.set_yticks(np.arange(-0.5, h, 1), minor=True)
        ax.grid(which='minor', color='white', linewidth=1)
        ax.tick_params(which='both', bottom=False, left=False, labelbottom=False, labelleft=False)
    
    legend_elements = []
    colors_in_grid = set()
    
    for row in input_grid + output_grid:
        colors_in_grid.update(set(row))
    
    colors_in_grid = sorted(list(colors_in_grid))
    for color in colors_in_grid:
        if color != 0:
            legend_elements.append(
                plt.Rectangle((0, 0), 1, 1, 
                            facecolor=ColorMapper.hex(color),
                            label=f"{color}: {ColorMapper.name(color)}")
            )
    
    if legend_elements:
        fig.legend(handles=legend_elements, 
                  loc='upper center', 
                  ncol=min(5, len(legend_elements)),
                  bbox_to_anchor=(0.5, 0.95))
    
    plt.suptitle("Analyse des Grilles - Système de Règles", 
                fontsize=16, fontweight='bold', y=0.98)
    plt.tight_layout(rect=[0, 0.05 if rules_text else 0, 1, 0.95])
    plt.show()


# ============================================
# PARTIE 5: EXTRACTION ET APPLICATION DE RÈGLES
# ============================================

class GridRuleExtractor:
    """Extrait les règles de transformation."""
    
    def __init__(self):
        self.color_changes = {}
        self.connections = {}
        self.translations = {}
        self.shape_rules = []
        
    def extract_from_examples(self, train_examples: List[Dict]) -> None:
        print("=== Extraction des règles depuis les exemples ===")
        
        for idx, example in enumerate(train_examples):
            print(f"\n--- Analyse de l'exemple {idx+1} ---")
            
            input_grid = example["input"]
            output_grid = example["output"]
            
            # Extraire les formes dans input et output
            input_rectangles = RectangleDetector.detect_rectangles(input_grid)
            output_rectangles = RectangleDetector.detect_rectangles(output_grid)
            
            input_lines = LineDetector.detect_lines(input_grid)
            output_lines = LineDetector.detect_lines(output_grid)
            
            print(f"  Rectangles détectés: {len(input_rectangles)} -> {len(output_rectangles)}")
            print(f"  Lignes détectées: {len(input_lines)} -> {len(output_lines)}")
            
            # Détecter les changements de couleur
            self._extract_color_changes(input_grid, output_grid)
            
            # Analyser les transformations
            self._analyze_transformations(input_grid, output_grid)
            
            # Analyser les transformations de formes
            self._analyze_shape_transformations(input_rectangles, output_rectangles, "rectangle")
            self._analyze_shape_transformations(input_lines, output_lines, "line")
    
    def _extract_color_changes(self, input_grid: List[List[int]], 
                               output_grid: List[List[int]]) -> None:
        h = len(input_grid)
        w = len(input_grid[0])
        
        for i in range(h):
            for j in range(w):
                old_color = input_grid[i][j]
                new_color = output_grid[i][j]
                
                if old_color != 0 and old_color != new_color:
                    if old_color in self.color_changes:
                        if self.color_changes[old_color] != new_color:
                            print(f"  Attention: conflit pour {old_color} -> {self.color_changes[old_color]} ou {new_color}")
                    self.color_changes[old_color] = new_color
                    print(f"  Changement couleur: {old_color} -> {new_color}")
    
    def _analyze_transformations(self, input_grid: List[List[int]], 
                                output_grid: List[List[int]]) -> None:
        h = len(input_grid)
        w = len(input_grid[0])
        
        input_points_by_color = defaultdict(set)
        output_points_by_color = defaultdict(set)
        
        for i in range(h):
            for j in range(w):
                c_in = input_grid[i][j]
                c_out = output_grid[i][j]
                if c_in != 0:
                    input_points_by_color[c_in].add((i, j))
                if c_out != 0:
                    output_points_by_color[c_out].add((i, j))
        
        for color_out in output_points_by_color.keys():
            possible_input_colors = []
            
            for old_color, new_color in self.color_changes.items():
                if new_color == color_out:
                    possible_input_colors.append(old_color)
            
            if color_out not in self.color_changes.values():
                possible_input_colors.append(color_out)
            
            input_points_for_color = set()
            for c_in in possible_input_colors:
                if c_in in input_points_by_color:
                    input_points_for_color.update(input_points_by_color[c_in])
            
            output_points = output_points_by_color[color_out]
            
            if not input_points_for_color:
                continue
            
            if not self._try_detect_translation(input_points_for_color, 
                                              output_points, color_out):
                self._try_detect_connection(input_points_for_color,
                                          output_points, color_out)
    
    def _analyze_shape_transformations(self, input_shapes: List[GeometricShape],
                                     output_shapes: List[GeometricShape],
                                     shape_type: str) -> None:
        """Analyse les transformations entre formes."""
        if not input_shapes or not output_shapes:
            return
        
        for in_shape in input_shapes:
            for out_shape in output_shapes:
                if in_shape.color == out_shape.color:
                    # Vérifier la translation
                    in_center = in_shape.bounding_box.center
                    out_center = out_shape.bounding_box.center
                    dx = out_center.x - in_center.x
                    dy = out_center.y - in_center.y
                    
                    if dx != 0 or dy != 0:
                        rule = {
                            "type": "shape_translation",
                            "shape_type": shape_type,
                            "color": in_shape.color,
                            "dx": dx,
                            "dy": dy,
                            "from_size": (in_shape.bounding_box.width, in_shape.bounding_box.height),
                            "to_size": (out_shape.bounding_box.width, out_shape.bounding_box.height)
                        }
                        self.shape_rules.append(rule)
                        print(f"  Translation de {shape_type}: ({dx}, {dy})")
    
    def _try_detect_translation(self, input_points: Set[Tuple[int, int]],
                               output_points: Set[Tuple[int, int]], 
                               color: int) -> bool:
        if len(input_points) != len(output_points) or not input_points:
            return False
        
        ref_in = next(iter(input_points))
        possible_displacements = set()
        
        for p_out in output_points:
            dx = p_out[0] - ref_in[0]
            dy = p_out[1] - ref_in[1]
            possible_displacements.add((dx, dy))
        
        for dx, dy in possible_displacements:
            match_all = True
            for p_in in input_points:
                moved = (p_in[0] + dx, p_in[1] + dy)
                if moved not in output_points:
                    match_all = False
                    break
            
            if match_all:
                for p_out in output_points:
                    original = (p_out[0] - dx, p_out[1] - dy)
                    if original not in input_points:
                        match_all = False
                        break
            
            if match_all:
                self.translations[color] = (dx, dy)
                print(f"  Translation pour {color}: ({dx}, {dy})")
                return True
        
        return False
    
    def _try_detect_connection(self, input_points: Set[Tuple[int, int]],
                              output_points: Set[Tuple[int, int]],
                              color: int) -> None:
        base_points = input_points.intersection(output_points)
        added_points = output_points - input_points
        
        if not added_points or len(base_points) < 2:
            return
        
        base_list = list(base_points)
        for i in range(len(base_list)):
            for j in range(i+1, len(base_list)):
                p1 = base_list[i]
                p2 = base_list[j]
                
                if p1[0] == p2[0]:  # Horizontal
                    min_y = min(p1[1], p2[1])
                    max_y = max(p1[1], p2[1])
                    line_points = {(p1[0], y) for y in range(min_y, max_y+1)}
                    
                    if line_points.issubset(output_points):
                        self.connections[color] = 'H'
                        print(f"  Connexion horizontale pour {color}")
                        return
                
                elif p1[1] == p2[1]:  # Vertical
                    min_x = min(p1[0], p2[0])
                    max_x = max(p1[0], p2[0])
                    line_points = {(x, p1[1]) for x in range(min_x, max_x+1)}
                    
                    if line_points.issubset(output_points):
                        self.connections[color] = 'V'
                        print(f"  Connexion verticale pour {color}")
                        return
                
                elif abs(p1[0] - p2[0]) == abs(p1[1] - p2[1]):  # Diagonale
                    dx = 1 if p2[0] > p1[0] else -1
                    dy = 1 if p2[1] > p1[1] else -1
                    steps = abs(p2[0] - p1[0])
                    line_points = {(p1[0] + k*dx, p1[1] + k*dy) 
                                   for k in range(steps+1)}
                    
                    if line_points.issubset(output_points):
                        self.connections[color] = 'D'
                        print(f"  Connexion diagonale pour {color}")
                        return
    
    def get_rules(self) -> Dict:
        return {
            "color_changes": self.color_changes,
            "connections": self.connections,
            "translations": self.translations,
            "shape_rules": self.shape_rules
        }


class GridTransformer:
    """Applique les règles de transformation."""
    
    def __init__(self, rules: Dict):
        self.color_changes = rules.get("color_changes", {})
        self.connections = rules.get("connections", {})
        self.translations = rules.get("translations", {})
        self.shape_rules = rules.get("shape_rules", [])
    
    def apply_rules(self, input_grid: List[List[int]]) -> List[List[int]]:
        grid = copy.deepcopy(input_grid)
        h = len(grid)
        w = len(grid[0])
        
        # Détecter les formes pour appliquer les règles de formes
        rectangles = RectangleDetector.detect_rectangles(grid)
        lines = LineDetector.detect_lines(grid)
        
        # Étape 1: Changements de couleur
        grid = self._apply_color_changes(grid)
        
        # Étape 2: Connexions
        grid = self._apply_connections(grid)
        
        # Étape 3: Translations
        grid = self._apply_translations(grid)
        
        # Étape 4: Règles de formes (si applicable)
        grid = self._apply_shape_rules(grid, rectangles, lines)
        
        return grid
    
    def _apply_color_changes(self, grid: List[List[int]]) -> List[List[int]]:
        h = len(grid)
        w = len(grid[0])
        
        for i in range(h):
            for j in range(w):
                if grid[i][j] in self.color_changes:
                    grid[i][j] = self.color_changes[grid[i][j]]
        
        return grid
    
    def _apply_connections(self, grid: List[List[int]]) -> List[List[int]]:
        h = len(grid)
        w = len(grid[0])
        
        for color, conn_type in self.connections.items():
            points = [(i, j) for i in range(h) for j in range(w) 
                     if grid[i][j] == color]
            
            if len(points) < 2:
                continue
            
            for k in range(len(points)):
                for l in range(k+1, len(points)):
                    p1 = points[k]
                    p2 = points[l]
                    
                    if conn_type == 'H' and p1[0] == p2[0]:
                        self._draw_horizontal_line(grid, p1, p2, color)
                    
                    elif conn_type == 'V' and p1[1] == p2[1]:
                        self._draw_vertical_line(grid, p1, p2, color)
                    
                    elif conn_type == 'D':
                        dx = p2[0] - p1[0]
                        dy = p2[1] - p1[1]
                        if abs(dx) == abs(dy):
                            self._draw_diagonal_line(grid, p1, p2, color)
        
        return grid
    
    def _draw_horizontal_line(self, grid: List[List[int]], 
                            p1: Tuple[int, int], p2: Tuple[int, int], 
                            color: int) -> None:
        row = p1[0]
        start_col = min(p1[1], p2[1])
        end_col = max(p1[1], p2[1])
        
        for col in range(start_col, end_col + 1):
            if grid[row][col] == 0:
                grid[row][col] = color
    
    def _draw_vertical_line(self, grid: List[List[int]], 
                          p1: Tuple[int, int], p2: Tuple[int, int], 
                          color: int) -> None:
        col = p1[1]
        start_row = min(p1[0], p2[0])
        end_row = max(p1[0], p2[0])
        
        for row in range(start_row, end_row + 1):
            if grid[row][col] == 0:
                grid[row][col] = color
    
    def _draw_diagonal_line(self, grid: List[List[int]], 
                          p1: Tuple[int, int], p2: Tuple[int, int], 
                          color: int) -> None:
        dx = 1 if p2[0] > p1[0] else -1
        dy = 1 if p2[1] > p1[1] else -1
        steps = abs(p2[0] - p1[0])
        
        for step in range(steps + 1):
            row = p1[0] + step * dx
            col = p1[1] + step * dy
            if grid[row][col] == 0:
                grid[row][col] = color
    
    def _apply_translations(self, grid: List[List[int]]) -> List[List[int]]:
        h = len(grid)
        w = len(grid[0])
        
        for color, (dx, dy) in self.translations.items():
            new_grid = copy.deepcopy(grid)
            
            for i in range(h):
                for j in range(w):
                    if grid[i][j] == color:
                        new_i = i + dx
                        new_j = j + dy
                        
                        new_grid[i][j] = 0
                        
                        if 0 <= new_i < h and 0 <= new_j < w:
                            new_grid[new_i][new_j] = color
            
            grid = new_grid
        
        return grid
    
    def _apply_shape_rules(self, grid: List[List[int]], 
                         rectangles: List[GeometricShape],
                         lines: List[GeometricShape]) -> List[List[int]]:
        """Applique les règles basées sur les formes détectées."""
        # Pour l'instant, on applique les translations de formes
        for rule in self.shape_rules:
            if rule["type"] == "shape_translation":
                # Cette partie est plus complexe et nécessite de manipuler
                # les formes complètes. À implémenter selon les besoins.
                pass
        
        return grid


# ============================================
# PARTIE 6: FONCTIONS PRINCIPALES
# ============================================

def load_data_from_json(filepath: str) -> Dict:
    with open(filepath, 'r', encoding='utf-8') as f:
        return json.load(f)

def save_results_to_json(results: Dict, filepath: str) -> None:
    with open(filepath, 'w', encoding='utf-8') as f:
        json.dump(results, f, indent=2)

def analyze_and_detect_shapes(grid: List[List[int]]):
    """Analyse une grille et détecte les formes."""
    print("\n=== DÉTECTION DE FORMES ===")
    
    rectangles = RectangleDetector.detect_rectangles(grid)
    lines = LineDetector.detect_lines(grid)
    
    print(f"Rectangles détectés: {len(rectangles)}")
    for rect in rectangles:
        print(f"  - Rectangle {rect.color}: {rect.bounding_box.width}x{rect.bounding_box.height}")
    
    print(f"Lignes détectées: {len(lines)}")
    for line in lines:
        print(f"  - Ligne {line.color}: {line.properties['direction']} ({line.properties['length']} pixels)")
    
    if rectangles or lines:
        visualize_shapes(grid, rectangles + lines, "Détection de formes")
    
    return rectangles, lines

def main(visualize: bool = True, json_file: str = "grid_data.json"):
    """Fonction principale."""
    print("Chargement des données...")
    try:
        data = load_data_from_json(json_file)
    except FileNotFoundError:
        print(f"Erreur: Fichier '{json_file}' non trouvé.")
        return
    
    # Analyser les exemples d'entraînement
    if visualize and "train" in data:
        for idx, example in enumerate(data["train"]):
            print(f"\n=== ANALYSE DE L'EXEMPLE {idx+1} ===")
            analyze_and_detect_shapes(example["input"])
    
    # Extraire les règles
    print("\n=== EXTRACTION DES RÈGLES ===")
    extractor = GridRuleExtractor()
    extractor.extract_from_examples(data["train"])
    rules = extractor.get_rules()
    
    print(f"\n=== RÈGLES EXTRACTES ===")
    print(f"Changements de couleur: {rules['color_changes']}")
    print(f"Connexions: {rules['connections']}")
    print(f"Translations: {rules['translations']}")
    print(f"Règles de formes: {len(rules['shape_rules'])}")
    
    # Visualisation des règles
    if visualize:
        visualize_rules_summary(rules)
    
    # Visualisation des exemples
    if visualize and "train" in data:
        print("\n=== VISUALISATION DES EXEMPLES ===")
        for idx, example in enumerate(data["train"]):
            visualize_grids(
                input_grid=example["input"],
                output_grid=example["output"],
                title_left=f"EXEMPLE {idx+1} - INPUT",
                title_right=f"EXEMPLE {idx+1} - OUTPUT",
                rules_text=f"Règles appliquées à l'exemple {idx+1}"
            )
    
    # Appliquer aux tests
    print(f"\n=== APPLICATION AUX TESTS ===")
    transformer = GridTransformer(rules)
    results = []
    
    test_key = "Test" if "Test" in data else "test"
    
    if test_key in data:
        for test_idx, test_case in enumerate(data[test_key]):
            print(f"\nTest {test_idx + 1}:")
            
            input_grid = test_case["input"]
            
            # Analyser les formes du test
            if visualize:
                analyze_and_detect_shapes(input_grid)
            
            output_grid = transformer.apply_rules(input_grid)
            
            results.append({
                "input": input_grid,
                "output": output_grid
            })
            
            if visualize:
                visualize_grids(
                    input_grid=input_grid,
                    output_grid=output_grid,
                    title_left=f"TEST {test_idx+1} - INPUT",
                    title_right=f"TEST {test_idx+1} - OUTPUT PRÉDIT",
                    rules_text="Règles appliquées automatiquement"
                )
    
    # Sauvegarder les résultats
    save_results_to_json({"test_results": results}, "grid_results.json")
    print(f"\nRésultats sauvegardés dans 'grid_results.json'")

def visualize_rules_summary(rules: Dict):
    """Visualise un résumé des règles."""
    fig, ax = plt.subplots(1, 1, figsize=(10, 6))
    
    rules_text = "=== RÈGLES EXTRACTES ===\n\n"
    
    rules_text += "CHANGEMENTS DE COULEUR:\n"
    if rules.get('color_changes'):
        for old_color, new_color in rules['color_changes'].items():
            rules_text += f"  {old_color} → {new_color}\n"
    else:
        rules_text += "  Aucun\n"
    
    rules_text += "\nCONNEXIONS:\n"
    if rules.get('connections'):
        for color, conn_type in rules['connections'].items():
            type_name = {'H': 'Horizontale', 'V': 'Verticale', 'D': 'Diagonale'}.get(conn_type, conn_type)
            rules_text += f"  Couleur {color}: {type_name}\n"
    else:
        rules_text += "  Aucune\n"
    
    rules_text += "\nTRANSLATIONS:\n"
    if rules.get('translations'):
        for color, (dx, dy) in rules['translations'].items():
            rules_text += f"  Couleur {color}: ({dx}, {dy})\n"
    else:
        rules_text += "  Aucune\n"
    
    rules_text += "\nRÈGLES DE FORMES:\n"
    if rules.get('shape_rules'):
        for rule in rules['shape_rules']:
            if rule["type"] == "shape_translation":
                rules_text += f"  {rule['shape_type']} {rule['color']}: ({rule['dx']}, {rule['dy']})\n"
    else:
        rules_text += "  Aucune\n"
    
    ax.text(0.1, 0.5, rules_text, 
            fontsize=12, 
            verticalalignment='center',
            bbox=dict(boxstyle='round', facecolor='lightyellow', alpha=0.8))
    
    ax.set_xlim(0, 1)
    ax.set_ylim(0, 1)
    ax.axis('off')
    ax.set_title("Règles Extraites des Exemples", fontsize=14, fontweight='bold')
    
    plt.tight_layout()
    plt.show()


# ============================================
# POINT D'ENTRÉE PRINCIPAL
# ============================================

if __name__ == "__main__":
    import sys
    
    print("SYSTÈME COMPLET DE RÉSOLUTION DE GRID ARC")
    print("=" * 50)
    
    visualize_input = input("Voulez-vous afficher les visualisations? (oui/non): ").strip().lower()
    visualize = visualize_input in ["oui", "o", "yes", "y"]
    
    json_file = input("Nom du fichier JSON (défaut: grid_data.json): ").strip()
    if not json_file:
        json_file = "grid_data.json"
    
    try:
        main(visualize=visualize, json_file=json_file)
    except Exception as e:
        print(f"Erreur lors de l'exécution: {e}")
        import traceback
        traceback.print_exc()
        print("\nAssurez-vous que les dépendances sont installées:")
        print("pip install matplotlib numpy")
        sys.exit(1)