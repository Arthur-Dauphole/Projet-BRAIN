"""
SYSTÈME AMÉLIORÉ AVEC CONSOLIDATION INTER-EXEMPLES
- Extrait les règles de chaque exemple
- Intercompare pour trouver des règles globales
- Génère les outputs pour les tests
"""

import json
import matplotlib.pyplot as plt
import numpy as np
from collections import defaultdict, Counter
from typing import List, Dict, Tuple, Set, Optional, Any
import copy
from dataclasses import dataclass, field
import statistics

# ============================================
# PARTIE 1: STRUCTURES DE DONNÉES POUR RÈGLES
# ============================================

@dataclass
class Rule:
    """Représente une règle de transformation."""
    rule_type: str  # 'color_change', 'translation', 'connection'
    params: Dict[str, Any]
    examples: List[int] = field(default_factory=list)  # Indices des exemples où cette règle apparaît
    confidence: float = 1.0  # Confiance statistique (0-1)
    
    def __hash__(self):
        return hash((self.rule_type, tuple(sorted(self.params.items()))))
    
    def __eq__(self, other):
        if not isinstance(other, Rule):
            return False
        return (self.rule_type == other.rule_type and 
                self.params == other.params)

@dataclass
class ConsolidatedRules:
    """Règles consolidées de tous les exemples."""
    color_changes: Dict[int, int]  # Règles spécifiques par couleur
    general_color_changes: List[Rule]  # Règles générales de changement couleur
    translations: Dict[int, Tuple[int, int]]  # Règles spécifiques par couleur
    general_translations: List[Rule]  # Règles générales de translation
    connections: Dict[int, str]  # Règles spécifiques par couleur
    general_connections: List[Rule]  # Règles générales de connexion
    
    def get_all_rules(self) -> Dict:
        """Retourne toutes les règles dans un format simple."""
        return {
            "color_changes": self.color_changes,
            "translations": self.translations,
            "connections": self.connections,
            "general_color_changes": [r.params for r in self.general_color_changes],
            "general_translations": [r.params for r in self.general_translations],
            "general_connections": [r.params for r in self.general_connections]
        }

# ============================================
# PARTIE 2: CONSOLIDATEUR DE RÈGLES
# ============================================

class RuleConsolidator:
    """Consolide les règles de différents exemples pour trouver des règles globales."""
    
    def __init__(self, min_confidence: float = 0.6):
        """
        Args:
            min_confidence: Seuil minimum de confiance pour une règle générale
                           (proportion d'exemples où elle apparaît)
        """
        self.min_confidence = min_confidence
        
        # Stockage des règles par type
        self.all_color_changes = defaultdict(list)  # old_color -> [(new_color, example_idx)]
        self.all_translations = defaultdict(list)   # color -> [(dx, dy, example_idx)]
        self.all_connections = defaultdict(list)    # color -> [(conn_type, example_idx)]
        
        # Pour la généralisation par forme
        self.shape_data = []  # Stocke les données de forme pour chaque exemple
    
    def add_example_rules(self, example_idx: int, 
                         color_changes: Dict[int, int],
                         translations: Dict[int, Tuple[int, int]],
                         connections: Dict[int, str]):
        """Ajoute les règles d'un exemple au consolidateur."""
        
        # Enregistrer les changements de couleur
        for old_color, new_color in color_changes.items():
            self.all_color_changes[old_color].append((new_color, example_idx))
        
        # Enregistrer les translations
        for color, (dx, dy) in translations.items():
            self.all_translations[color].append(((dx, dy), example_idx))
        
        # Enregistrer les connexions
        for color, conn_type in connections.items():
            self.all_connections[color].append((conn_type, example_idx))
    
    def add_shape_data(self, example_idx: int, input_grid: List[List[int]], 
                      output_grid: List[List[int]]):
        """Analyse les formes pour détecter des motifs communs."""
        # Ici on pourrait ajouter une analyse de forme
        # Pour l'instant, on se concentre sur les règles pixel/vecteur
        pass
    
    def consolidate(self) -> ConsolidatedRules:
        """Consolide toutes les règles et retourne les règles finales."""
        
        # 1. Consolider les changements de couleur
        color_changes = self._consolidate_color_changes()
        general_color_rules = self._extract_general_color_rules()
        
        # 2. Consolider les translations
        translations = self._consolidate_translations()
        general_translation_rules = self._extract_general_translation_rules()
        
        # 3. Consolider les connexions
        connections = self._consolidate_connections()
        general_connection_rules = self._extract_general_connection_rules()
        
        return ConsolidatedRules(
            color_changes=color_changes,
            general_color_changes=general_color_rules,
            translations=translations,
            general_translations=general_translation_rules,
            connections=connections,
            general_connections=general_connection_rules
        )
    
    def _consolidate_color_changes(self) -> Dict[int, int]:
        """Consolide les changements de couleur par couleur."""
        consolidated = {}
        
        for old_color, changes in self.all_color_changes.items():
            # Compter les changements les plus fréquents
            change_counter = Counter()
            for new_color, _ in changes:
                change_counter[new_color] += 1
            
            if change_counter:
                # Prendre le changement le plus fréquent
                most_common = change_counter.most_common(1)[0]
                new_color, count = most_common
                
                # Vérifier la confiance (au moins 60% des occurrences)
                confidence = count / len(changes)
                if confidence >= self.min_confidence:
                    consolidated[old_color] = new_color
                    print(f"  Changement couleur consolidé: {old_color} -> {new_color} (confiance: {confidence:.2f})")
        
        return consolidated
    
    def _extract_general_color_rules(self) -> List[Rule]:
        """Extrait des règles générales de changement de couleur."""
        general_rules = []
        
        # Regrouper par type de changement (ex: "augmentation de 1")
        change_patterns = defaultdict(list)
        
        for old_color, changes in self.all_color_changes.items():
            for new_color, example_idx in changes:
                # Calculer la différence
                diff = new_color - old_color
                pattern = f"diff_{diff}"
                change_patterns[pattern].append((old_color, new_color, example_idx))
        
        # Chercher des motifs récurrents
        for pattern, occurrences in change_patterns.items():
            if len(occurrences) >= 2:
                # Vérifier si c'est cohérent
                examples_with_pattern = set(idx for _, _, idx in occurrences)
                confidence = len(examples_with_pattern) / len(self.all_color_changes)
                
                if confidence >= self.min_confidence:
                    # Extraire la différence
                    diff = int(pattern.split('_')[1])
                    rule = Rule(
                        rule_type="general_color_change",
                        params={"type": "add_constant", "value": diff},
                        examples=list(examples_with_pattern),
                        confidence=confidence
                    )
                    general_rules.append(rule)
                    print(f"  Règle générale couleur: ajouter {diff} (confiance: {confidence:.2f})")
        
        return general_rules
    
    def _consolidate_translations(self) -> Dict[int, Tuple[int, int]]:
        """Consolide les translations par couleur."""
        consolidated = {}
        
        for color, translations in self.all_translations.items():
            # Compter les translations les plus fréquentes
            translation_counter = Counter()
            for (dx, dy), _ in translations:
                translation_counter[(dx, dy)] += 1
            
            if translation_counter:
                # Prendre la translation la plus fréquente
                most_common = translation_counter.most_common(1)[0]
                (dx, dy), count = most_common
                
                # Vérifier la confiance
                confidence = count / len(translations)
                if confidence >= self.min_confidence:
                    consolidated[color] = (dx, dy)
                    print(f"  Translation consolidée: couleur {color} -> ({dx}, {dy}) (confiance: {confidence:.2f})")
        
        return consolidated
    
    def _extract_general_translation_rules(self) -> List[Rule]:
        """Extrait des règles générales de translation."""
        general_rules = []
        
        # Étape 1: Regrouper toutes les translations par vecteur
        vector_to_colors = defaultdict(set)
        vector_to_examples = defaultdict(set)
        
        for color, translations in self.all_translations.items():
            for (dx, dy), example_idx in translations:
                vector = (dx, dy)
                vector_to_colors[vector].add(color)
                vector_to_examples[vector].add(example_idx)
        
        # Étape 2: Chercher des vecteurs qui apparaissent pour plusieurs couleurs
        for vector, colors in vector_to_colors.items():
            if len(colors) >= 2:  # Au moins 2 couleurs différentes
                dx, dy = vector
                examples = vector_to_examples[vector]
                confidence = len(examples) / len(set().union(*[set(idx for (_, idx) in self.all_translations[c]) for c in colors]))
                
                if confidence >= self.min_confidence:
                    # Règle générale: ce vecteur s'applique indépendamment de la couleur
                    rule = Rule(
                        rule_type="general_translation",
                        params={"dx": dx, "dy": dy, "applies_to": "all_colors"},
                        examples=list(examples),
                        confidence=confidence
                    )
                    general_rules.append(rule)
                    print(f"  Règle générale translation: ({dx}, {dy}) pour {len(colors)} couleurs (confiance: {confidence:.2f})")
        
        # Étape 3: Chercher des motifs directionnels (ex: toujours vers la droite)
        directions = defaultdict(list)
        for color, translations in self.all_translations.items():
            for (dx, dy), example_idx in translations:
                if dx > 0 and dy == 0:
                    directions["right"].append((color, example_idx))
                elif dx < 0 and dy == 0:
                    directions["left"].append((color, example_idx))
                elif dx == 0 and dy > 0:
                    directions["down"].append((color, example_idx))
                elif dx == 0 and dy < 0:
                    directions["up"].append((color, example_idx))
        
        for direction, occurrences in directions.items():
            if len(occurrences) >= 2:
                colors = set(color for color, _ in occurrences)
                examples = set(idx for _, idx in occurrences)
                confidence = len(examples) / len(self.all_translations)
                
                if confidence >= self.min_confidence and len(colors) >= 2:
                    rule = Rule(
                        rule_type="general_translation",
                        params={"direction": direction, "applies_to": "all_colors"},
                        examples=list(examples),
                        confidence=confidence
                    )
                    general_rules.append(rule)
                    print(f"  Règle générale direction: {direction} (confiance: {confidence:.2f})")
        
        return general_rules
    
    def _consolidate_connections(self) -> Dict[int, str]:
        """Consolide les connexions par couleur."""
        consolidated = {}
        
        for color, connections in self.all_connections.items():
            # Compter les types de connexion les plus fréquents
            connection_counter = Counter()
            for conn_type, _ in connections:
                connection_counter[conn_type] += 1
            
            if connection_counter:
                # Prendre le type le plus fréquent
                most_common = connection_counter.most_common(1)[0]
                conn_type, count = most_common
                
                # Vérifier la confiance
                confidence = count / len(connections)
                if confidence >= self.min_confidence:
                    consolidated[color] = conn_type
                    print(f"  Connexion consolidée: couleur {color} -> {conn_type} (confiance: {confidence:.2f})")
        
        return consolidated
    
    def _extract_general_connection_rules(self) -> List[Rule]:
        """Extrait des règles générales de connexion."""
        general_rules = []
        
        # Regrouper par type de connexion
        connection_types = defaultdict(set)
        connection_examples = defaultdict(set)
        
        for color, connections in self.all_connections.items():
            for conn_type, example_idx in connections:
                connection_types[conn_type].add(color)
                connection_examples[conn_type].add(example_idx)
        
        # Chercher des types qui apparaissent pour plusieurs couleurs
        for conn_type, colors in connection_types.items():
            if len(colors) >= 2:
                examples = connection_examples[conn_type]
                confidence = len(examples) / len(self.all_connections)
                
                if confidence >= self.min_confidence:
                    rule = Rule(
                        rule_type="general_connection",
                        params={"connection_type": conn_type, "applies_to": "all_colors"},
                        examples=list(examples),
                        confidence=confidence
                    )
                    general_rules.append(rule)
                    print(f"  Règle générale connexion: {conn_type} pour {len(colors)} couleurs (confiance: {confidence:.2f})")
        
        return general_rules
    
    def print_statistics(self):
        """Affiche les statistiques de consolidation."""
        print("\n" + "="*60)
        print("STATISTIQUES DE CONSOLIDATION")
        print("="*60)
        
        print(f"\nChangements de couleur analysés: {len(self.all_color_changes)} couleurs")
        for color, changes in self.all_color_changes.items():
            print(f"  Couleur {color}: {len(changes)} occurrences")
        
        print(f"\nTranslations analysées: {len(self.all_translations)} couleurs")
        for color, translations in self.all_translations.items():
            print(f"  Couleur {color}: {len(translations)} translations")
            vectors = Counter((dx, dy) for (dx, dy), _ in translations)
            for (dx, dy), count in vectors.most_common(3):
                print(f"    → ({dx}, {dy}): {count} fois")
        
        print(f"\nConnexions analysées: {len(self.all_connections)} couleurs")
        for color, connections in self.all_connections.items():
            print(f"  Couleur {color}: {len(connections)} connexions")

# ============================================
# PARTIE 3: EXTRACTION DE RÈGLES AVEC CONSOLIDATION
# ============================================

class AdvancedGridRuleExtractor:
    """Extrait et consolide les règles de tous les exemples."""
    
    def __init__(self, min_confidence: float = 0.6):
        self.consolidator = RuleConsolidator(min_confidence)
        self.example_rules = []  # Stocke les règles de chaque exemple
        
    def extract_and_consolidate(self, train_examples: List[Dict]) -> ConsolidatedRules:
        """Extrait les règles de chaque exemple et les consolide."""
        print("="*60)
        print("EXTRACTION ET CONSOLIDATION DES RÈGLES")
        print("="*60)
        
        for idx, example in enumerate(train_examples):
            print(f"\n--- Analyse de l'exemple {idx+1} ---")
            
            input_grid = example["input"]
            output_grid = example["output"]
            
            # Extraire les règles de cet exemple
            color_changes, translations, connections = self._extract_single_example(input_grid, output_grid)
            
            # Stocker pour référence
            self.example_rules.append({
                "color_changes": color_changes,
                "translations": translations,
                "connections": connections
            })
            
            # Ajouter au consolidateur
            self.consolidator.add_example_rules(
                idx, color_changes, translations, connections
            )
            
            # Ajouter les données de forme (pour analyses futures)
            self.consolidator.add_shape_data(idx, input_grid, output_grid)
        
        # Afficher les statistiques
        self.consolidator.print_statistics()
        
        # Consolider toutes les règles
        print("\n" + "="*60)
        print("CONSOLIDATION FINALE")
        print("="*60)
        consolidated_rules = self.consolidator.consolidate()
        
        return consolidated_rules
    
    def _extract_single_example(self, input_grid: List[List[int]], 
                               output_grid: List[List[int]]) -> Tuple[Dict, Dict, Dict]:
        """Extrait les règles d'un seul exemple."""
        color_changes = {}
        translations = {}
        connections = {}
        
        h = len(input_grid)
        w = len(input_grid[0])
        
        # Points par couleur
        input_points_by_color = defaultdict(set)
        output_points_by_color = defaultdict(set)
        
        # 1. Détecter les changements de couleur
        for i in range(h):
            for j in range(w):
                old_color = input_grid[i][j]
                new_color = output_grid[i][j]
                
                if old_color != 0 and old_color != new_color:
                    color_changes[old_color] = new_color
                
                if old_color != 0:
                    input_points_by_color[old_color].add((i, j))
                if new_color != 0:
                    output_points_by_color[new_color].add((i, j))
        
        # 2. Pour chaque couleur en sortie, analyser les transformations
        for color_out in output_points_by_color.keys():
            # Trouver la couleur d'entrée correspondante
            possible_input_colors = []
            
            for old_color, new_color in color_changes.items():
                if new_color == color_out:
                    possible_input_colors.append(old_color)
            
            if color_out not in color_changes.values():
                possible_input_colors.append(color_out)
            
            # Points d'entrée correspondants
            input_points_for_color = set()
            for c_in in possible_input_colors:
                if c_in in input_points_by_color:
                    input_points_for_color.update(input_points_by_color[c_in])
            
            output_points = output_points_by_color[color_out]
            
            if not input_points_for_color:
                continue
            
            # Essayer de détecter une translation
            translation_found = self._try_detect_translation(
                input_points_for_color, output_points, color_out
            )
            if translation_found:
                dx, dy = translation_found
                translations[color_out] = (dx, dy)
            else:
                # Sinon, essayer de détecter une connexion
                conn_type = self._try_detect_connection(
                    input_points_for_color, output_points, color_out
                )
                if conn_type:
                    connections[color_out] = conn_type
        
        return color_changes, translations, connections
    
    def _try_detect_translation(self, input_points: Set[Tuple[int, int]],
                               output_points: Set[Tuple[int, int]], 
                               color: int) -> Optional[Tuple[int, int]]:
        """Détecte une translation."""
        if len(input_points) != len(output_points) or not input_points:
            return None
        
        ref_in = next(iter(input_points))
        possible_displacements = set()
        
        for p_out in output_points:
            dx = p_out[0] - ref_in[0]
            dy = p_out[1] - ref_in[1]
            possible_displacements.add((dx, dy))
        
        for dx, dy in possible_displacements:
            match_all = True
            for p_in in input_points:
                moved = (p_in[0] + dx, p_in[1] + dy)
                if moved not in output_points:
                    match_all = False
                    break
            
            if match_all:
                for p_out in output_points:
                    original = (p_out[0] - dx, p_out[1] - dy)
                    if original not in input_points:
                        match_all = False
                        break
            
            if match_all:
                return (dx, dy)
        
        return None
    
    def _try_detect_connection(self, input_points: Set[Tuple[int, int]],
                              output_points: Set[Tuple[int, int]],
                              color: int) -> Optional[str]:
        """Détecte une connexion."""
        base_points = input_points.intersection(output_points)
        added_points = output_points - input_points
        
        if not added_points or len(base_points) < 2:
            return None
        
        base_list = list(base_points)
        for i in range(len(base_list)):
            for j in range(i+1, len(base_list)):
                p1 = base_list[i]
                p2 = base_list[j]
                
                if p1[0] == p2[0]:  # Horizontal
                    min_y = min(p1[1], p2[1])
                    max_y = max(p1[1], p2[1])
                    line_points = {(p1[0], y) for y in range(min_y, max_y+1)}
                    
                    if line_points.issubset(output_points):
                        return 'H'
                
                elif p1[1] == p2[1]:  # Vertical
                    min_x = min(p1[0], p2[0])
                    max_x = max(p1[0], p2[0])
                    line_points = {(x, p1[1]) for x in range(min_x, max_x+1)}
                    
                    if line_points.issubset(output_points):
                        return 'V'
                
                elif abs(p1[0] - p2[0]) == abs(p1[1] - p2[1]):  # Diagonale
                    dx = 1 if p2[0] > p1[0] else -1
                    dy = 1 if p2[1] > p1[1] else -1
                    steps = abs(p2[0] - p1[0])
                    line_points = {(p1[0] + k*dx, p1[1] + k*dy) 
                                   for k in range(steps+1)}
                    
                    if line_points.issubset(output_points):
                        return 'D'
        
        return None

# ============================================
# PARTIE 4: APPLICATION AVEC RÈGLES GÉNÉRALES
# ============================================

class AdvancedGridTransformer:
    """Applique les règles consolidées (spécifiques + générales)."""
    
    def __init__(self, consolidated_rules: ConsolidatedRules):
        self.rules = consolidated_rules
        
    def apply_rules(self, input_grid: List[List[int]]) -> List[List[int]]:
        """
        Applique les règles dans l'ordre:
        1. Changements de couleur (spécifiques → généraux)
        2. Connexions (spécifiques → généraux)
        3. Translations (spécifiques → généraux)
        """
        grid = copy.deepcopy(input_grid)
        h = len(grid)
        w = len(grid[0])
        
        # 1. Changements de couleur
        grid = self._apply_color_changes(grid)
        
        # 2. Connexions
        grid = self._apply_connections(grid)
        
        # 3. Translations
        grid = self._apply_translations(grid)
        
        return grid
    
    def _apply_color_changes(self, grid: List[List[int]]) -> List[List[int]]:
        """Applique les changements de couleur (spécifiques et généraux)."""
        h = len(grid)
        w = len(grid[0])
        
        # D'abord les règles spécifiques
        for i in range(h):
            for j in range(w):
                color = grid[i][j]
                if color in self.rules.color_changes:
                    grid[i][j] = self.rules.color_changes[color]
        
        # Ensuite les règles générales (si applicables)
        for rule in self.rules.general_color_changes:
            if rule.params.get("type") == "add_constant":
                value = rule.params["value"]
                for i in range(h):
                    for j in range(w):
                        old_color = grid[i][j]
                        if old_color != 0:
                            new_color = old_color + value
                            if 0 <= new_color <= 9:
                                grid[i][j] = new_color
        
        return grid
    
    def _apply_connections(self, grid: List[List[int]]) -> List[List[int]]:
        """Applique les connexions (spécifiques et générales)."""
        h = len(grid)
        w = len(grid[0])
        
        # Fonction pour appliquer une connexion d'un type donné à une couleur
        def apply_connection_type(conn_type: str, color: int):
            # Trouver tous les points de cette couleur
            points = [(i, j) for i in range(h) for j in range(w) 
                     if grid[i][j] == color]
            
            if len(points) < 2:
                return
            
            # Pour chaque paire de points
            for k in range(len(points)):
                for l in range(k+1, len(points)):
                    p1 = points[k]
                    p2 = points[l]
                    
                    if conn_type == 'H' and p1[0] == p2[0]:
                        self._draw_horizontal_line(grid, p1, p2, color)
                    elif conn_type == 'V' and p1[1] == p2[1]:
                        self._draw_vertical_line(grid, p1, p2, color)
                    elif conn_type == 'D':
                        dx = p2[0] - p1[0]
                        dy = p2[1] - p1[1]
                        if abs(dx) == abs(dy):
                            self._draw_diagonal_line(grid, p1, p2, color)
        
        # Appliquer d'abord les règles spécifiques
        for color, conn_type in self.rules.connections.items():
            apply_connection_type(conn_type, color)
        
        # Ensuite les règles générales
        for rule in self.rules.general_connections:
            conn_type = rule.params["connection_type"]
            # Appliquer à toutes les couleurs présentes
            colors_in_grid = set()
            for i in range(h):
                for j in range(w):
                    if grid[i][j] != 0:
                        colors_in_grid.add(grid[i][j])
            
            for color in colors_in_grid:
                # Ne pas réappliquer si déjà fait par une règle spécifique
                if color not in self.rules.connections:
                    apply_connection_type(conn_type, color)
        
        return grid
    
    def _draw_horizontal_line(self, grid: List[List[int]], 
                            p1: Tuple[int, int], p2: Tuple[int, int], 
                            color: int) -> None:
        row = p1[0]
        start_col = min(p1[1], p2[1])
        end_col = max(p1[1], p2[1])
        
        for col in range(start_col, end_col + 1):
            if grid[row][col] == 0:
                grid[row][col] = color
    
    def _draw_vertical_line(self, grid: List[List[int]], 
                          p1: Tuple[int, int], p2: Tuple[int, int], 
                          color: int) -> None:
        col = p1[1]
        start_row = min(p1[0], p2[0])
        end_row = max(p1[0], p2[0])
        
        for row in range(start_row, end_row + 1):
            if grid[row][col] == 0:
                grid[row][col] = color
    
    def _draw_diagonal_line(self, grid: List[List[int]], 
                          p1: Tuple[int, int], p2: Tuple[int, int], 
                          color: int) -> None:
        dx = 1 if p2[0] > p1[0] else -1
        dy = 1 if p2[1] > p1[1] else -1
        steps = abs(p2[0] - p1[0])
        
        for step in range(steps + 1):
            row = p1[0] + step * dx
            col = p1[1] + step * dy
            if grid[row][col] == 0:
                grid[row][col] = color
    
    def _apply_translations(self, grid: List[List[int]]) -> List[List[int]]:
        """Applique les translations (spécifiques et générales)."""
        h = len(grid)
        w = len(grid[0])
        
        # Créer une nouvelle grille
        new_grid = [[0 for _ in range(w)] for _ in range(h)]
        
        # 1. Copier tout ce qui ne sera pas translaté
        for i in range(h):
            for j in range(w):
                color = grid[i][j]
                if color != 0:
                    # Vérifier si cette couleur a une règle spécifique
                    if color in self.rules.translations:
                        # Cette couleur sera traitée plus tard
                        continue
                    
                    # Vérifier si une règle générale s'applique
                    general_applies = False
                    for rule in self.rules.general_translations:
                        if rule.params.get("applies_to") == "all_colors":
                            general_applies = True
                            break
                    
                    if not general_applies:
                        # Garder à la même position
                        new_grid[i][j] = color
        
        # 2. Appliquer les translations spécifiques
        for color, (dx, dy) in self.rules.translations.items():
            for i in range(h):
                for j in range(w):
                    if grid[i][j] == color:
                        new_i = i + dy
                        new_j = j + dx
                        
                        if 0 <= new_i < h and 0 <= new_j < w:
                            new_grid[new_i][new_j] = color
        
        # 3. Appliquer les translations générales
        for rule in self.rules.general_translations:
            if rule.params.get("applies_to") == "all_colors":
                dx = rule.params.get("dx", 0)
                dy = rule.params.get("dy", 0)
                
                # Appliquer à toutes les couleurs qui n'ont pas de règle spécifique
                for i in range(h):
                    for j in range(w):
                        color = grid[i][j]
                        if color != 0 and color not in self.rules.translations:
                            new_i = i + dy
                            new_j = j + dx
                            
                            if 0 <= new_i < h and 0 <= new_j < w:
                                new_grid[new_i][new_j] = color
        
        return new_grid

# ============================================
# PARTIE 5: FONCTIONS PRINCIPALES AVEC VISUALISATION AMÉLIORÉE
# ============================================

def grid_to_rgb_with_grid(grid: List[List[int]], grid_color='white', grid_alpha=0.3, line_width=1):
    """Convertit une grille en image RGB avec des lignes de grille."""
    h, w = len(grid), len(grid[0])
    
    # Carte de couleurs améliorée
    color_map = {
        0: [0, 0, 0],        # Noir
        1: [1, 0, 0],        # Rouge
        2: [0, 0, 1],        # Bleu
        3: [0, 1, 0],        # Vert
        4: [1, 1, 0],        # Jaune
        5: [0.5, 0.5, 0.5],  # Gris
        6: [1, 0, 1],        # Magenta
        7: [1, 0.5, 0],      # Orange
        8: [0, 1, 1],        # Cyan
        9: [0.5, 0, 0]       # Marron
    }
    
    # Créer l'image RGB
    rgb = np.zeros((h, w, 3))
    for i in range(h):
        for j in range(w):
            rgb[i, j] = color_map.get(grid[i][j], [1, 1, 1])
    
    return rgb

def visualize_with_grid(grid: List[List[int]], ax, title: str = ""):
    """Visualise une grille avec des lignes de grille claires."""
    h, w = len(grid), len(grid[0])
    
    # Créer l'image RGB
    rgb = grid_to_rgb_with_grid(grid)
    
    # Afficher l'image
    ax.imshow(rgb)
    ax.set_title(title, fontsize=12, fontweight='bold', pad=10)
    
    # Ajouter des lignes de grille
    ax.set_xticks(np.arange(-0.5, w, 1), minor=True)
    ax.set_yticks(np.arange(-0.5, h, 1), minor=True)
    ax.grid(which='minor', color='white', linewidth=1, alpha=0.7)
    
    # Cacher les ticks
    ax.set_xticks([])
    ax.set_yticks([])
    
    # Ajouter un quadrillage pour mieux voir les pixels
    for x in range(w):
        for y in range(h):
            # Rectangle autour de chaque pixel
            rect = plt.Rectangle((x-0.5, y-0.5), 1, 1,
                               linewidth=0.5, 
                               edgecolor=(1, 1, 1, 0.5),
                               facecolor='none')
            ax.add_patch(rect)

def main(visualize: bool = True, json_file: str = "grid_data.json"):
    """Fonction principale avec consolidation inter-exemples."""
    
    # Charger les données
    print("Chargement des données...")
    try:
        with open(json_file, 'r', encoding='utf-8') as f:
            data = json.load(f)
    except FileNotFoundError:
        print(f"Erreur: Fichier '{json_file}' non trouvé.")
        return
    
    # Extraire et consolider les règles
    print("\nExtraction et consolidation des règles...")
    extractor = AdvancedGridRuleExtractor(min_confidence=0.5)
    consolidated_rules = extractor.extract_and_consolidate(data["train"])
    
    # Afficher les règles finales
    print("\n" + "="*60)
    print("RÈGLES FINALES (CONSOLIDÉES)")
    print("="*60)
    
    all_rules = consolidated_rules.get_all_rules()
    print(f"\nChangements de couleur spécifiques: {all_rules['color_changes']}")
    print(f"Changements de couleur généraux: {all_rules['general_color_changes']}")
    print(f"\nTranslations spécifiques: {all_rules['translations']}")
    print(f"Translations généraux: {all_rules['general_translations']}")
    print(f"\nConnexions spécifiques: {all_rules['connections']}")
    print(f"Connexions généraux: {all_rules['general_connections']}")
    
    # Appliquer aux tests
    print(f"\n" + "="*60)
    print("APPLICATION AUX TESTS")
    print("="*60)
    
    transformer = AdvancedGridTransformer(consolidated_rules)
    results = []
    
    # Chercher les tests
    test_key = "Test" if "Test" in data else "test"
    
    if test_key in data:
        for test_idx, test_case in enumerate(data[test_key]):
            print(f"\n=== TEST {test_idx + 1} ===")
            
            input_grid = test_case["input"]
            print(f"Input (taille: {len(input_grid)}x{len(input_grid[0])}):")
            if len(input_grid) <= 8:
                for row in input_grid[:min(8, len(input_grid))]:
                    print("  " + str(row))
            else:
                for row in input_grid[:4]:
                    print("  " + str(row))
                print("  ...")
                for row in input_grid[-4:]:
                    print("  " + str(row))
            
            # Générer l'output
            output_grid = transformer.apply_rules(input_grid)
            
            print(f"\nOutput prédit (taille: {len(output_grid)}x{len(output_grid[0])}):")
            if len(output_grid) <= 8:
                for row in output_grid[:min(8, len(output_grid))]:
                    print("  " + str(row))
            else:
                for row in output_grid[:4]:
                    print("  " + str(row))
                print("  ...")
                for row in output_grid[-4:]:
                    print("  " + str(row))
            
            results.append({
                "input": input_grid,
                "output": output_grid
            })
            
            # Visualisation améliorée avec grilles
            if visualize:
                fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 6))
                
                # Input avec grille
                visualize_with_grid(input_grid, ax1, f"TEST {test_idx+1} - INPUT")
                
                # Output avec grille
                visualize_with_grid(output_grid, ax2, f"TEST {test_idx+1} - OUTPUT PRÉDIT")
                
                # Ajouter une légende des couleurs
                colors_present = set()
                for row in input_grid + output_grid:
                    colors_present.update(set(row))
                colors_present.discard(0)
                
                if colors_present:
                    legend_text = "Couleurs:\n"
                    color_names = {
                        1: "Rouge", 2: "Bleu", 3: "Vert", 4: "Jaune",
                        5: "Gris", 6: "Magenta", 7: "Orange", 
                        8: "Cyan", 9: "Marron"
                    }
                    for color in sorted(colors_present):
                        if color in color_names:
                            legend_text += f"{color}: {color_names[color]}\n"
                    
                    # Positionner la légende
                    plt.figtext(0.02, 0.98, legend_text, 
                               fontsize=9, verticalalignment='top',
                               bbox=dict(boxstyle='round', facecolor='lightgray', alpha=0.8))
                
                plt.suptitle(f"Visualisation du Test {test_idx+1}", fontsize=14, fontweight='bold')
                plt.tight_layout()
                plt.show()
    
    # Sauvegarder les résultats
    with open("grid_results_consolidated.json", 'w', encoding='utf-8') as f:
        json.dump({"test_results": results}, f, indent=2)
    
    print(f"\n✓ Terminé! {len(results)} test(s) traités.")
    print(f"✓ Résultats sauvegardés dans 'grid_results_consolidated.json'")
    
    return results

# ============================================
# EXÉCUTION
# ============================================

if __name__ == "__main__":
    import sys
    
    print("="*70)
    print("SYSTÈME AVEC CONSOLIDATION INTER-EXEMPLES")
    print("="*70)
    
    # Demander le fichier
    json_file = input("Nom du fichier JSON (défaut: grid_data.json): ").strip()
    if not json_file:
        json_file = "grid_data.json"
    
    # Mode visualisation
    visualize_input = input("Visualisation? (oui/non): ").strip().lower()
    visualize = visualize_input in ["oui", "o", "yes", "y"]
    
    try:
        main(visualize=visualize, json_file=json_file)
    except Exception as e:
        print(f"Erreur: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)